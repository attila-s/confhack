you 
 um 
 big 
 you are actually very serious when you 
 are recording me 
 what did i learn today 
 well i learned that there is a great 
 python community in prague 
 and it would be great to 
 organize maybe the next euro python 
 there that would be fantastic a great 
 city great people great beer 
 that that would be fantastic 
 [Music] 
 today i learned 
 um well how to do an interview i guess 
 the community the people 
 and talking 
 and 
 learning new things 
 i don't know it's fun 
 we had a really interesting discussion 
 about euro python society and you know 
 how 
 things were before how things are right 
 now there were some really interesting 
 conversations about what could be done 
 to be like more community centered for 
 us to be more community centered how we 
 can help more open source um 
 organizations and more specifically just 
 be more closer to the community 
 so today at europe when i learned about 
 how 
 the new python versions will be 
 optimized and how they will run faster i 
 think that's great news for the future 
 of python 
 the euro python is the gathering of 
 different groups different faults 
 different ideas and but everybody is 
 sticking together with a common language 
 which is python something i really liked 
 learning about which was really cool was 
 these 
 vs code pets which you can have some 
 pets running around in vs code and what 
 i really like about europe python is uh 
 now that we're not remote anymore is 
 actually talking to people meeting 
 people and interacting and especially 
 comparing 
 developer setups which we were just 
 doing just now that's really cool 
 during 
 our preparations for europe iphone i've 
 learned some animal parts like 
 that giraffes have actually vocal uh 
 vocals and they can speak 
 everything everyone does with python and 
 that's probably one of my favorite 
 things and is the surprises you get from 
 even when you read the abstracts of the 
 talks and you get you think you know 
 what they're going to be talking about 
 and then you go to a talk that you think 
 you will not enjoy that much and it just 
 completely blows your mind 
 and that's that's really really cool 
 this year in europe i learned a lot 
 about the streaming and 
 video cameras and other things knowing 
 people and 
 knowing 
 many different society europa society 
 members 
 community members but i think it's 
 very important if you want to be 
 occupied 
 if you want to participate 
 i think my favorite thing about euro 
 python is well the people the people 
 around python is just fantastic it's the 
 best people i've ever met 
 for me it's like a 
 nerd cam for all the nerds so it's 
 really nice to meet all the people that 
 i see only once per year at the 
 conference 
 talks are really nice i 
 i learned for example about linters for 
 the import statements which i still have 
 to read about but 
 i learned quite a lot from that 
 this year meeting a lot of friends in 
 person so i've been in europe for three 
 years and this is my first time meeting 
 all of you 
 in real life and that was just amazing 
 it was i got five minutes five minutes 
 to prepare for a session share and then 
 after all i got loads of people coming 
 saying thank you and to say that they 
 loved it so i think that was a great job 
 and i had fun doing it 
 i think every every day there is 
 something new and funny 
 i think it's just fantastic i highly 
 recommend your python and hopefully see 
 you next year 
 umnitsa is the enterprise technology 
 management solution that consolidates 
 data from existing siloed tools to 
 provide a single source of truth for 
 endpoints applications cloud networking 
 and accessories 
 with imnitza you can automate processes 
 from purchase to end of life achieving 
 five key benefits 
 find out how umnitsa can give you 
 complete control and insight across your 
 technology portfolios book a live demo 
 today at umnitza.com 
 [Music] 
 [Music] 
 [Music] 
 you are actually very serious when you 
 are recording me 
 what did i learn today 
 well i learned that there is a great 
 python community in prague 
 and it would be great to 
 organize maybe the next european there 
 that would be fantastic a great city 
 great people great beer 
 that that would be fantastic 
 today today i learned 
 well how to do an interview i guess 
 the community the people and talking 
 and 
 learning new things 
 i don't know it's fun 
 we had a really interesting discussion 
 about european society and you know how 
 things were before how things are right 
 now there were some really interesting 
 conversations about what could be done 
 to be like more community centered for 
 us to be more community centered how we 
 can help more open source um 
 organizations and more specifically just 
 be more closer to the community 
 so today at euro python i learned about 
 how 
 the new python versions will be 
 optimized and how they will run faster i 
 think that's great news for the future 
 of python 
 the europa python is the gathering of 
 different groups different faults 
 different ideas and but everybody is 
 sticking together with a common language 
 which is python something i really liked 
 learning about which was really cool was 
 these 
 vs code pets which you can have some 
 pets running around in vs code and what 
 i really like about your python is uh 
 now that we're not remote anymore it's 
 actually talking to people meeting 
 people and interacting and especially 
 comparing 
 developer setups which we were just 
 doing just now that's really cool 
 during 
 our preparations for your python i've 
 learned some animal parts like uh that 
 giraffes have actually vocal 
 vocals and they can speak 
 everything everyone does with python and 
 that's probably one of my favorite 
 things and is the surprises you get from 
 even when you read the abstracts of the 
 talks and you get you think you know 
 what they're going to be talking about 
 and then you go to a talk that you think 
 you will not enjoy that much and it just 
 completely blows your mind 
 and that's that's really really cool 
 this year in europe i learned a lot 
 about the streaming and 
 video cameras and other things knowing 
 people and knowing 
 many different societal 
 member and 
 community members but i think it's 
 very important if you want to be 
 occupied 
 if you want to participate 
 i think my favorite thing about euro 
 python is well the people the people 
 real fighters are just fantastic it's 
 the best people i've ever met 
 for me it's like a 
 nerd camp for all the nerds so it's 
 really nice to meet all the people that 
 i see only once per year at the 
 conference talks are really nice i 
 i learned for example about linters for 
 the import statements which i still have 
 to read about but 
 i learned quite a lot from that 
 this year meeting a lot of friends in 
 person so i've been in europe for three 
 years and this is my first time meeting 
 all of you 
 in real life and that was just amazing 
 i got five minutes five minutes to 
 prepare for a session share and then 
 after all i got loads of people coming 
 saying thank you and say that they loved 
 it so i think that was a great job 
 and i had fun doing it 
 i think every every day there is 
 something new and funny 
 i think it's just fantastic highly 
 recommend europe python and hopefully 
 see you next year 
 umnitza is the enterprise technology 
 management solution that consolidates 
 data from existing siloed tools to 
 provide a single source of truth for 
 endpoints applications cloud networking 
 and accessories 
 with imnitza you can automate processes 
 from purchase to end of life achieving 
 five key benefits 
 find out how omnitsa can give you 
 complete control and insight across your 
 technology portfolios book a live demo 
 today at umnitza.com 
 [Music] 
 so 
 do 
 [Music] 
 you are actually very serious when you 
 are recording me 
 what did i learn today 
 well i learned that there is a great 
 python community in prague 
 and it would be great to organize maybe 
 the next euro python there that would be 
 fantastic a great city great people 
 great beer 
 that that would be fantastic 
 today today i learned 
 well how to do an interview i guess 
 the community the people 
 and talking 
 and 
 learning new things 
 i don't know it's fun 
 we had a really interesting discussion 
 about european society and you know how 
 um things were before how things are 
 right now there were some really 
 interesting conversations about what 
 could be done to be like more community 
 centered for us to be more community 
 centered how we can help more open 
 source organizations and more 
 specifically just be more closer to the 
 community 
 so today at euro python i learned about 
 how 
 the new python versions will be 
 optimized and how they will run faster i 
 think that's great news for the future 
 of python the european is the gathering 
 of 
 different groups different faults 
 different ideas and but everybody is 
 sticking together with a common language 
 which is python something i really liked 
 learning about which was really cool was 
 these 
 vs code pets which you can have some 
 pets running around in vs code and what 
 i really like about your python is uh 
 now that we're not remote anymore is 
 actually talking to people meeting 
 people and interacting and especially 
 comparing 
 developer setups which we were just 
 doing just now that's really cool 
 during uh our preparations for europe 
 iphone i've learned some animal parts 
 like 
 that giraffes have actually vocal 
 vocals and they can speak everything 
 everyone does with python and that's 
 probably one of my favorite things and 
 is the surprises you get from 
 even when you read the abstracts of the 
 talks and you get you think you know 
 what they're going to be talking about 
 and then you go to a talk that you think 
 you will not enjoy that much and it just 
 completely blows your mind 
 and that's that's really really cool 
 this year in europe i learned a lot 
 about the streaming and 
 video cameras and other things knowing 
 people and knowing 
 many 
 different society europa society and 
 finance 
 community members but i think it's 
 very important if you want to be 
 occupied 
 if you want to participate 
 i think my favorite thing about euro 
 python is well the people the people 
 real quiet are just fantastic it's the 
 best people i've ever met 
 for me it's like a 
 nerd camp for 
 all the nerds so it's really nice to 
 meet all the people that i see only once 
 per year at the conference 
 talks are really nice i 
 i learned for example about linters for 
 the import statements which i still have 
 to read about but 
 i learned quite a lot from that 
 this year meeting a lot of friends in 
 person so i've been in europe for three 
 years and this is my first time meeting 
 all of you 
 in real life and that was just 
 was i got five minutes five minutes 
 prepare for a session chair and then 
 after all i got loads 
 foreign 
 good morning and welcome to the third 
 day of talks at euro python i also like 
 to re-welcome the remote viewers on 
 venulis our first speaker today is 
 lukasz and he's going to tell us how to 
 embed a python interpreter in ios 
 please give a big round of applause to 
 lukas 
 hi 
 welcome to snakes on airplane mode or 
 embedding python 
 in ios applications i usually say i'm 
 mukash i come from the internet but 
 since ireland is essentially a polish 
 colony right now um like i'm from poznan 
 which is in the western part of poland 
 um i invite you to visit it's nice 
 back in 2019 i went to london to give a 
 keynote about uh how python should not 
 only be used for data science it should 
 be used 
 in more ways like 
 this pew pew console that uh like i 
 was using back then uh i got it from 
 radome and in fact you could use it on 
 this very conference at a workshop 
 earlier in the week uh but i also talked 
 about like webassembly which is 
 happening now and like mobile devices 
 which we're gonna make work now as well 
 so um 
 what do i mean by you know actually 
 embedding and why do we even want this 
 like this talk is going to go through 
 all of this we're gonna begin with just 
 you know 
 kind of appreciating swift the language 
 that uh ios developers do use for uh 
 development uh as a kind of first class 
 language then we're gonna say like okay 
 so if you have swift and like 
 why would you even 
 want python there too 
 and if you wanted like how would you 
 actually make it to build so that apple 
 will be fine with it running on an 
 embedded device on an ios device 
 and if you already 
 have it compiled such that it does work 
 we're going to talk about like how to 
 actually use it from within the ios app 
 and finally we're going to actually run 
 some code for you to actually believe 
 that this is all actually practically 
 useful 
 uh before we begin like a question i 
 already got asked at the conference 
 since this is the last day and we've 
 been here for a while like it's like why 
 would you 
 actually want this you know the app 
 store like has swift it had objective 
 cb4 so sure like objective c has been 
 with us since 84 uh and it's been used 
 uh for ios applications like you know 
 pretty much like from 
 day one when um the sdk was released 
 it's been the language of the year in 
 2011 and 2012 and this is because of ios 
 like back then there were 
 like 
 three quarters of a million apps in the 
 app store which ended up paying out 
 over seven billion dollars to developers 
 so you know it was like two-thirds of 
 the market for uh mobile applications 
 were ios so everybody was like crazy 
 about objective c 
 only later they found out you know when 
 they were actually trying to make those 
 apps that they crash a lot and it's kind 
 of awkward to write them because the 
 syntax is very unfamiliar and what not 
 in one dot so apple saw that they're 
 hitting a wall with adoption through 
 objective-c being kind of like a legacy 
 language they tried to 
 kind of make it more modern with 
 objective-c 2.0 with garbage collection 
 that was later kind of 
 deprecated because it worked kind of 
 lousily on mobile devices 
 but it turned out not to be the way so 
 they released uh 
 swift in 2014 and like four years later 
 it already overtook objective c 
 with adoption so like apparently they 
 did something right like it was the most 
 loved programming language dubbed by the 
 stack overflow developer survey in 2015 
 and second place in 2016. 
 clearly only possible because python was 
 struggling with the 2.223 uh transition 
 then but you know still we have to give 
 it to them that you know most loved 
 programming language um 
 and you know redmond 
 redmonk.com says that in a world in 
 which it's incredibly difficult to break 
 into the top 25 
 of language 
 rankings let alone the top 10 swift 
 manage the chore in less than four years 
 it remains a growth phenomenon okay so 
 clearly they did something right there 
 but obviously when we're looking at this 
 chart we're mostly interested in this 
 we're at a python conference where the 
 first year like yes uh language of the 
 year 2007 2010 2018 2020 2021 and good 
 chance of doing it again for 2022. in 
 fact like the top four languages they're 
 like have like nearly 50 adoption so you 
 know kind of 
 we're there we're winning so maybe we 
 should just upset you know on 
 swift and just kind of start doing 
 mobile applications 
 that way 
 well 
 i don't believe that i think 
 that swift as the language of choice by 
 apple and make made kind of the official 
 platform tooling is always going to be 
 better than using something that is 
 third party and tries to play catch up 
 and like you know make stuff magically 
 work on multiple platforms yes there are 
 multiple options for this there's react 
 native there's flutter 
 there's 
 beware that the python community is 
 working on but i personally just my 
 personal opinion think that you know you 
 should be using the best tool at your 
 disposal 
 so 
 why do we even have this talk then well 
 because 
 i'm a heavy note notetaker like i have 
 like thousands of notes on my phone like 
 they're synchronized to my mac and i do 
 a bunch of things with them including 
 like publishing my website and you know 
 there's a bunch of automation that i do 
 all the time and i'm able to do it on 
 the mac because i just run the python 
 but i cannot do any of this on the phone 
 and it's annoying because i already have 
 those python scripts usually they're not 
 even like numpy you know 
 natural language processing stuff it's 
 just regular 
 boring python like that uses the style 
 library and i still cannot use this so i 
 found that there was an app 
 on the app store that allowed me to use 
 python to you know model workflows like 
 ifttt you know and kind of write small 
 scripts but it turns out like this was 
 python 2 and this is no longer 
 maintained so it was like kind of like a 
 bomber i saw like what is this developer 
 doing now so oh they're doing pythonista 
 this is like an entire ide that is 
 running on your phone where you can do 
 like mini apps and you know can run them 
 within python style but they can be 
 graphical they can interact with the 
 operating system you can have like 
 widgets and whatever like it's like okay 
 that's cool 
 also not maintained for like three years 
 now so 
 i was looking at an alternative and emma 
 cole 
 worked on and still works on pyto which 
 is sort of like pythonista 
 but actually maintained like and pretty 
 powerful like on the website you can see 
 you know that it allows for running 
 python 310 which is awesome like you 
 know an actual modern version of python 
 you can run this it includes numpy metal 
 lib and whatever this is paid which i 
 kind of agree with her like you know it 
 this entire pytho app is open source so 
 you can kind of download it and you know 
 try it for on your own but if you want 
 to have like include the libraries and a 
 bunch of other things like you know this 
 is a paid on uh on the app store like 
 the reason why is that if it were in the 
 case you would have like tens of copycat 
 apps that do exactly the same and then 
 you know it's a support nightmare for 
 the actual author so open source is kind 
 of you know um 
 we want it but at the same time like 
 people don't play the game fair all the 
 time so the fact that part of it is paid 
 is good by me but you know plenty of 
 awesome features but again this is not 
 what i wanted i just wanted a text 
 editor to be able to automate it like i 
 didn't want to write my text editor 
 within python and just run it as a 
 python mini app like that's that's not 
 what i what i wanted uh back when my 
 haircut was kind of quite different like 
 i actually was saying that python is 
 runnable like you know 13 year olds can 
 program it so this is what i wanted to 
 do 
 to let people write swift apps that are 
 modern that are first class on ios but 
 allow people 
 allow users to extend them to customize 
 them right and is this something that 
 anybody is doing well 
 as far as i can tell not on ios but in 
 the in the world of desktop applications 
 that is a tremendously popular thing to 
 do you have like blender right which is 
 you know kind of industry grade 3d 
 modeling software and it has a python 
 api right you have a bespoke synth like 
 a modular synthesizer that can be 
 scripted with python you can just make 
 it play notes generatively and whatever 
 uh if you're a youtuber or an aspiring 
 youtuber you know obs and that thing can 
 also be scripted by python so you know 
 all of this is pretty popular in fact 
 even production grade digital audio 
 workstations like apple studio here can 
 be programmed with python so 
 clearly the market is there people want 
 this since like supporting um 
 multi-platform python embedding is not 
 an easy job 
 so the fact that all those pieces of 
 software industry-grade pieces of 
 software not toys like actual 
 professionals use them the fact that 
 they want um python apis there 
 means that this is something that the 
 users are actually 
 well 
 wanting 
 so should we actually unseat swift no we 
 should make swift talk to python and you 
 know uh the vice versa so this is what 
 we are going to do next 
 in practice in life because we live 
 dangerously 
 we'll be using bewares python 311 for 
 ios 
 scripting so like you know kind of setup 
 since python 311 does not build cleanly 
 on ios 
 i wish we're not there yet 
 we will be there at some point i do hope 
 to work with beware to make 312 um 
 pretty much 
 compile for ios with no changes so 
 we'll see as a developer in residence i 
 think you know i'm well positioned to 
 actually make this happen 
 we'll be using python kit to talk from 
 swift to python and vice versa 
 that was originally created for swift 
 for tensorflow that was an attempt to 
 replace python in terms of flow with 
 swift 
 and this is now a project that was 
 cancelled so clearly again use the best 
 tool for the job turns out that python 
 is the best tool for 
 orchestrating machine learning um you 
 switch tried to unseat that didn't work 
 but we will be using swift ui which is 
 the kind of latest and greatest in uh 
 creating uh mobile applications for ios 
 the fun fact about this is that there's 
 not going to be any objective c inside 
 so before we actually look at code be 
 aware viewer tries to make 
 python applications run on mobile in 
 ways where you write a single codebase 
 and you can run it on android and on ios 
 with pretty much no changes um and 
 there's also like a linux port so you 
 can run it on desktop as well 
 we're not going to be using beware today 
 we're going to be using like 
 a support element of viewer which allows 
 to python the programming language be 
 built 
 in a way that can be embedded inside an 
 iphone application 
 so what is this python apple support 
 thing like why do we need it well it is 
 a gigantic patch file that makes tiny 
 changes to many tiny changes to python 
 such that we can actually compile it 
 with clang on on xcode and make it embed 
 uh but it's also like a make file that 
 is like a thousand lines long that uh 
 kind of provides like a ton of steps 
 that you know have to be made 
 for the actual artifact to be acceptable 
 by xcode so with having all this in mind 
 demo time 
 cool 
 so 
 uh 
 oh before we begin let me show you 
 something cool 
 all uh the things that we're going to be 
 doing we're going to be doing in in 
 memory because i have 64 gigs so why use 
 disk um 
 so let's switch to ram disk see python 
 no we're not going to be working on c 
 python now i mostly have it to to run c 
 python because you can compile it in 
 like eight seconds in ram 
 uh but now we're just going to clone 
 an app that i wrote 
 in 
 swift ui we're going to talk about it in 
 a second so let's go there 
 see what we have here okay so let's just 
 open this bullseye xcode project 
 okay we have an xcode application it is 
 a very very simple swift ui application 
 um 
 it's got an app object which you can see 
 that there's literally just some state 
 you know we call it a game and there's a 
 single content view like a single window 
 in a single sheet for like a leaderboard 
 so like very simple there's a bunch of 
 views but it's only because you know 
 it's like an html you have a bunch of 
 components that are like just nested 
 inside one another so we're just 
 switching them like you know 
 splitting them into multiple files just 
 so that this file the main file doesn't 
 look terrible 
 in xcode you can actually see the 
 preview of it so let's wait until this 
 builds and you know in a moment we 
 should see yeah this is like 
 the the smallest thing you can call a 
 game so you know it's like put the 
 bullseye as close to the number 19 so 
 you literally put the sliders close to 
 19 and hit me and like if if you got 19 
 you get like many points if you got 90 
 you you're gonna get less points because 
 it wanted 19. 
 um yeah so like very simple application 
 but it already kind of this is with ui 
 so it's it's proper ios so like it works 
 you know in both orientations it will 
 work in dark mode as well which we can 
 actually check here like by switching to 
 the dark you know uh 
 and back and whatever so yeah like all 
 of this kind of works very nicely uh 
 this isn't even the simulator uh well 
 you can obviously run the entire 
 application in a simulator i have my 
 phone connected it's called lucky 13 
 because it's an iphone 13 mini and i'm 
 lucky because minis are just well shaped 
 for my hands but now let's just use the 
 oldest device that can actually run this 
 so a simulator of 
 ipod touch which i don't believe they 
 sell anymore but you know it is what it 
 is 
 uh so this is going to take a while and 
 then the simulator is going to hopefully 
 show us something it doesn't show us yet 
 okay so we can you know kind of attempt 
 to or 14 maybe here i don't know 
 15. okay so we got 149 points awesome 
 and now we're in round two we can do 
 five so phi is going to be closer okay 
 five oh 200 points because i perfect you 
 know bullseye 
 amazing that was not scripted that's 
 just my talent um 
 yeah so 
 it has like a leaderboard obviously it's 
 stupid you know you don't log in you 
 don't do anything but like it just shows 
 you like there's a there's a card that 
 you can swipe out you know it's like 
 this is like a modern switch why app 
 doesn't have like many lines of code you 
 can reset your progress if you don't 
 like to have many points you can just 
 start over that that's that's the thing 
 that's the app like it's it's not very 
 complicated what we will want to do is 
 to replace this logic that like 
 calculates the point with python right 
 so this is what we're going to be doing 
 uh so let's stop the simulator uh 
 in fact like before we even do anything 
 else like let's try to run it on the 
 phone so that i'm sure that actually it 
 does run 
 because it will be awkward like in a 
 minute when i if it wouldn't 
 uh but it should be fine so build 
 succeeded 
 and it says running but can we see it 
 well i i hope we can uh 
 look this is my phone from quicktime 
 player so you can actually see me 
 manipulating the phone 
 right like and it actually does a thing 
 to prove you that this is actually the 
 phone like this is the phone connect 
 don't message me now uh 
 yeah actually i don't trust him not to 
 do it so let's put focus do not disturb 
 okay yeah so this is my actual phone 
 like and we're running this app right so 
 like it's a pretty nice developer 
 experience we're gonna put python there 
 the reason why i'm so like you know 
 insisted on like oh look this is the ui 
 this is the simulator this is the device 
 is that all three steps fail running 
 python in different ways so i can show 
 you that we can actually run it in all 
 three scenarios which is important if 
 you actually want to develop 
 applications later 
 okay so let's stop the application right 
 now 
 and put our 
 uh 
 python 
 thing in it 
 oh no this is too small so let's just 
 change to this directory where i was 
 before which was this 
 uh python apple support uh let me show 
 you what's in it uh 
 i see it on the wrong screen but here it 
 is so it's essentially 
 this make file and everything and it has 
 a bunch of distribution files that we 
 will be literally dragging and dropping 
 into 
 uh 
 into our xcode project so let's do it 
 right now 
 uh oh or maybe not like let's create 
 some folders so that we organize things 
 as civilized people do so frameworks so 
 we're going to put the frameworks that 
 we built 
 uh 
 and also resources we're going to 
 put the stand library of python so boom 
 resources 
 i can barely see it but like okay 
 hopefully no typos so frameworks um 
 and we want to put those xc frameworks 
 there 
 there's a bunch of them it's kind of 
 weird but you know like i'll explain it 
 in a second 
 so we're putting it over frameworks we 
 do want to copy them inside 
 if you do that then github wants you to 
 pay them because now your uh you know 
 kind of dot a files are going to be very 
 big and this is no longer free tier of 
 github so welcome to for professional 
 development 
 this takes a little while to compile 
 because it's like oh i don't know what 
 this is like it'll resolve it in a 
 moment in the meantime we can add the 
 standard library of python which is in 
 this python folder you see like 
 resources lib python 311 we also want 
 that we will be using that so let's 
 let's add it to resources 
 okay 
 and now 
 after all those uh question marks 
 disappeared 
 we will 
 experience xcode lying to us many times 
 this is going to be a story of failure 
 but i want you to actually see these 
 failures because if you actually skip a 
 step and end up seeing this i don't want 
 you to just see the final solution first 
 i want you to see the failure so like we 
 can actually know like oh like this is 
 how this is all so 
 now we put python there we don't use it 
 yet at all but like does it build 
 uh we press yes and it says it does 
 build it will say that it cannot run it 
 because i have my phone locked but i 
 unlock it and now it's running uh let me 
 switch to the simulator later 
 in fact i want to do it because i want 
 to show you that python is not at all 
 there yet 
 so let's switch to iphone touch ad again 
 press play 
 build succeeded awesome it shows cool 
 how can we see if it's there there's 
 multiple civilized ways to do it but we 
 don't have time for that 
 so let's see it in the simplest way ever 
 xcode allows you to see the build folder 
 in finder so we have the build folder 
 again in the wrong screen let's uh bring 
 it here 
 this we don't need anymore and you see 
 that oh there's a bullseye app it has 
 like a you know an icon that suggests 
 that it won't run on this computer 
 because it's an ios app but we can look 
 inside and we see that the bullseye 
 thing is 700 kilobytes big okay cool but 
 the python 
 um 
 parts which are like yeah the headers we 
 don't need lit python.a is 70 megs big 
 so if your application is 700 kilobytes 
 you can pretty much know that nothing 
 happened like this wasn't actually not 
 included like it's it's it's not good um 
 by the way you you can see that those 
 headers that are needed for xcode to 
 show us things but what's actually 
 linked is this dot 8 file so clearly we 
 have to fix something so uh 
 well we should make sure that there's a 
 framework that is actually like included 
 in this app so is it included 
 xcode claims it is uh it lists it under 
 frameworks because it we put it you know 
 in a nicely called directory and it 
 looks like a framework so it lists it 
 it says do not embed we actually don't 
 want to embed because what that would 
 mean is 
 dynamically loaded libraries would be 
 embedded inside our application we have 
 dot a files they should be linked with 
 the binary 
 that should end up like a single code 
 object so we don't want to embed that's 
 fine we want to link 
 do we link it in build phases we should 
 see link binary with libraries and 
 they're all listed so they should link 
 but they're not being linked why not oh 
 it turns out that i need help with that 
 from corey benfield um 
 if you look in that project you will see 
 like a lot of headers you know so like 
 all those dot h files uh and among them 
 the main one that we want is python uh 
 python.h 
 uh if you open it it will say entry 
 point of the python c api this is what 
 people include when they want python 
 so we actually do need to say this to 
 the swift compiler that like hey this is 
 the dot h file that we you you need uh 
 to 
 look for to embed so let's make a new 
 file 
 and create a module map 
 where's an empty file here 
 empty i just want an empty file give me 
 an empty file please oh empty 
 documentation markdown close enough 
 uh 
 so let's let's put it wherever say 
 bullseye and and call it module dot 
 module map 
 okay 
 yes not mark down dude ah still mark now 
 okay um 
 we want to have a module called python 
 and that module will have an umbrella 
 that's a nice keyword i like that they 
 have a keyword called umbrella um 
 header 
 python.h right we all we just look at it 
 we want to export everything from it 
 we're greedy and we want to link python 
 that's it but we want to put it in a 
 good place 
 so let's show this in finder 
 there's more finders i want to see all 
 of them okay frameworks so those headers 
 need this module map so let's give it 
 the module map 
 uh what is happening 
 okay 
 let's copy this file over here by the 
 way all of those things are the things 
 that i hope with 311 are going to be 
 just automatic um so but for now if you 
 want to actually use this for the next 
 two years like this is what you have to 
 do so this already will run on the 
 device hopefully it's a lie but like you 
 know you can hope uh and then we also 
 have to make it work on the simulator 
 by the way what's fun uh you'll see that 
 the simulators 
 live.a is twice as big it's because it's 
 a fat library which runs on both arm and 
 intel 
 so that's good uh the device one doesn't 
 have to have like fat binaries because 
 it's only arm 
 okay so with this in mind like that 
 should already 
 fix our problem right 
 so let's try to run it stop the previous 
 one 
 run this one 
 build succeeded 
 it did appear 
 and this is still 800 kilobytes that's 
 not good and the reason why is that the 
 swift compiler tries really hard not to 
 link things in if it's not entirely sure 
 it needs them because otherwise mobile 
 apps would be terribly big 
 and nobody wants to download hundreds of 
 megs over you know kind of their data 
 roaming in a different country 
 so we actually have to in our app say 
 import python what's this python well 
 that's exactly this this thing that we 
 just uh defined this module that we just 
 defined 
 and we actually have to use it so we 
 have to define some fake function called 
 please link python 
 and here we we need to use some part of 
 this c api like pi 
 initialize say like it's it's how you 
 would initialize like an um python 
 interpreter with the c api 
 uh what is that what does this say 
 please link python 
 oh yeah of course 
 cool so in a minute like this should 
 disappear okay 
 now let's try again 
 and see some progress 
 oh progress errors that's good that 
 means like we went somewhere further 
 what are those errors there's hundreds 
 of them but among them you will see that 
 there's like stuff oh sqlite is missing 
 why didn't viewer add it well because it 
 ships with uh ios you don't have to 
 actually add it again like it would be 
 wasteful again your binary would be 
 bigger than it needs to be so when we 
 link stuff we just need to say we want 
 sqlite and in ios we ship a sqlite 
 version so let's add it and let me just 
 already 
 lib z is also needed so let's add that 
 too 
 so yeah tbd by the way not to be 
 determined it's text-based description i 
 also didn't know what that is i asked 
 apple people and they said text-based 
 description 
 now we're smart okay cool let's try it 
 again both succeeded 
 it runs 
 and now 
 12 megs still smaller it's weird ah 
 because the swift compiler is actually 
 smart and like within the binary there's 
 a bunch of like debug symbols and stuff 
 that actually does not link to python.h 
 so we're not in fact linking those but 
 we're linking python now so this is 
 success now we actually have python 
 inside our simulator 
 so we can start doing stuff with it 
 but 
 what we have right now is this import 
 python thing that um exposes uh the c 
 api of python which is super low level 
 you have like stuff like incrementing 
 and decrementing reference counts and 
 whatever like this is not really what 
 you want to do if you're writing in a 
 high level language like swift so 
 instead what can you do there's a bunch 
 of things for objective c but again we 
 don't want to use objective c and 
 there's one cool thing for swift uh 
 called python kit which 
 originally came from 
 uh the swift4 tensorflow project so we 
 can add it by just saying we want a 
 dependency you can you also use 
 cocoapods or uh carthage but like let's 
 just do it like graphically here and you 
 say 
 from github 
 uh i already have this here but you know 
 it's like this entire link here just add 
 python kit so you just paste this entire 
 link here and say add package and now 
 conference wi-fi will allow me to add 
 the package it did which is amazing 
 and we can see that there's already some 
 code there it's some cute like 
 swift code that does the thing that we 
 wanted which is uh like converting all 
 the types to python objects and whatever 
 we don't need any of uh to do any of 
 this we can just be users so now 
 uh inside say our models right so this 
 game uh class that has just like you 
 know what is the number that you should 
 be hitting what is the current score you 
 have which round of the game it is is it 
 now and so on and so on 
 uh we can start using python so before 
 we had this nice function points that 
 was written in swift uh we actually are 
 like you know good programmers so we 
 even wrote tests for it so we know that 
 uh if we get like bullseye we get 200 
 points if we get like one off like we're 
 gonna have 149 because you get 100 extra 
 points for hitting bullseye 50 if you're 
 within five points and if you're like 
 very far you just get as many points as 
 the distance from the perfect score so 
 we can run the test here with this nice 
 button and instead of line 23 
 uh it'll take a while but build 
 succeeded and hopefully it's green yeah 
 okay it's green for now all gonna fix 
 this now 
 uh 
 because green is is boring 
 okay so uh 
 let's bring up the game again 
 so this is swift points oh you don't 
 want swift we want python 
 and the reason why i wanted 
 to show you this is that this the syntax 
 of using python inside swift with python 
 kit looks super nice you actually have 
 to import python kit first so let's do 
 it okay we imported python kit but now 
 what we can do is we can say that we 
 will have random and random is a python 
 library that we're just importing 
 so we imported a python library and now 
 inside swift we can literally say that 
 we want to say return a random rand int 
 how we never give a thousand points in 
 the swift version so let's say between a 
 thousand and two thousand so we know 
 that we're actually running python uh it 
 will not be happy with us uh because 
 what is it well rand and returns uh 
 which we can check uh with 
 option click 
 it returns no it doesn't return anything 
 oh it returns essentially like a python 
 object right so we need to convert it to 
 an end in fact like let's see that it's 
 like result so you'll see what type it 
 is 
 yeah it's a python object right uh so we 
 need to convert it to 
 an integer so that um 
 [Music] 
 result 
 or like let's convert it right here 
 and 
 yeah and that's almost fine 
 like if we put result here 
 it'll still yell at us because you know 
 it's python what if you don't actually 
 return on it well then there's going to 
 be nil so you're going to have to say 
 well for this particular purpose we're 
 not going to do try catch or whatever 
 we're just going to say 
 yeah like it'll be it if it's not end 
 then the app will crash okay fine but 
 this is fine for now for like a short 
 short talk like you don't do it in 
 actual applications on the app store 
 okay so now let's see if this actually 
 does anything 
 build succeeded let me just press hit me 
 and gives us like thousands of points 
 this is python running inside the swift 
 ui app 
 i'm already happy with this this is 
 already cool 
 and now what we could do is we could 
 keep writing swift using python 
 libraries this is not exactly what we 
 want right like we want to actually 
 write like longer python pieces of code 
 so 
 even though this is cool let's extend 
 this and just actually create a 
 file 
 inside our resources oh we're going to 
 be calling say script ui 
 uh annoyingly 
 just like recently 
 xcode removed support for python syntax 
 highlighting because of the new parser 
 so we're going to be left with just like 
 regular black uh colors here but yeah we 
 can do the same thing here so like we 
 can say import random we're going to 
 have like uh def points but you know 
 there's a guess of end and you know 
 we're gonna be returning an end and here 
 like we can return what uh this random 
 rent in 
 thousand 
 to 2000 it's the same thing but in a 
 python module so okay like will this 
 work like in spoiler alert it won't uh 
 you know if you just replace this with 
 script 
 script 
 and say script points 
 uh 
 script points guess 
 this should ideally work but what will 
 actually happen 
 is something that we know from python 
 which is 
 an import error oh we cannot find the 
 file 
 why well because we never configured 
 where our files are so let's do that if 
 you get import errors 
 you should tell 
 your python kit uh 
 where where your modules live usually 
 you don't have to do this when you're 
 using python kit um inside um like 
 mac applications which is what python 
 kit was created for but for here you do 
 need to be a little hacky like i hope to 
 improve this in python kit in the future 
 but for now you really have to use some 
 environment variables 
 we're going to be doing this but just as 
 you don't import things inside functions 
 in python we don't really want to import 
 things inside of a function here because 
 what this will do is it will 
 actually instantiate a new interpreter 
 with every call which is like super 
 wasteful for your battery and everything 
 so instead let's just say that we are 
 going to have our script which is a 
 python object everything is a python 
 object in python 
 and here we just want to instantiate 
 this 
 but 
 no there's no let anymore 
 and this indentation is making me crazy 
 somebody should write an order formatter 
 for this 
 um 
 yeah cool so 
 what we want to do is uh to find a 
 directory for python resources so the 
 way you do it is just to say path is a 
 bundle which is what you actually have 
 like this bundle with your app and like 
 all those other files the main bundle 
 which is actually what ships and we want 
 to have a path to a resource which is 
 path 
 for 
 resource and we want to have this python 
 slash resources directory it actually 
 wants you to say of which type so what 
 is the file extension there is no file 
 extension 
 uh yeah so if we have this because like 
 it can also be nil you know it might not 
 be fine it found so if it is actually 
 found 
 uh then we want to set it 
 inside the python path variable you 
 remember python path it's like you know 
 days of yours you know maybe there 
 should be virtual and no no virtual 
 environments for this okay so path yes 
 and replace whatever you found so like 
 yeah always said it 
 uh 
 okay 
 this should this should disappear all is 
 good cool 
 so will this find our application now it 
 should if it won't i will be surprised 
 okay 
 boom it found our file again so now we 
 can actually code here inside the script 
 you know we can actually put more code 
 we can now like do more imports we can 
 do interesting things 
 but again i set up all this phone and 
 thing 
 to 
 show you whether this works on a phone 
 and like spoiler alert this does not yet 
 work on the phone we're close 
 but no 
 not no cigar yet 
 so if you actually stop this 
 and want to run it on lucky 13 you'll be 
 unlucky for a while 
 it'll do it you'll do exactly the same 
 uh yeah there's warnings that's fine uh 
 it'll be running so let me show you that 
 it's 
 oh it's not running current thread no 
 python frame it's like something is 
 wrong no module named encodings this is 
 terrible 
 why oh because it look 
 looks on my phone for this path this 
 path will never be found on my phone 
 because this is my dropbox directory on 
 my uh 
 on my laptop 
 oh okay so what we need to do is 
 we need to 
 [Music] 
 and that's in the app right 
 no we were putting the script in the 
 game 
 um 
 yeah so we need to also set python home 
 which is the environment that actually 
 says what's your prefix 
 this ideally should be programmatically 
 set and not the way we're doing it right 
 now this is hacky but it will work for 
 now and we'll work with python kit so 
 that this is smoother 
 uh for now though we can actually press 
 uh play here you know and build 
 succeeded which is good enough it 
 actually started let me show you that 
 there is an app on the phone right now 
 okay and if i play around with it 
 i can actually hit it bad and still get 
 thousands of points and i can hit it oh 
 maybe well 
 almost yeah but see like you know this 
 is this is the thing and there's like a 
 leaderboard and whatever like you know 
 so 
 we made it work now it works on the 
 simulator and on the device you can ship 
 this apple will accept it in the app 
 store it's good um i could go on now if 
 i had more time because you know now 
 this is where the interesting stuff 
 happens where you can just start coding 
 in python like it's it's awesome but the 
 talk was about the setup which took me 
 like weeks to actually go through it 
 because there's multiple choices for 
 each of the step which library you want 
 to do uh like build python 311 with like 
 because this is 311 so you're one of the 
 first people to see 311 working on on a 
 phone um 
 but also um like you know the thing is 
 now you can do many many wonderful 
 things 
 with uh with apps so some ideas for this 
 would be you know you can 
 make users script their apps right so 
 they could like automate some workflows 
 they could customize their apps right 
 they could uh do like 
 uh app behavior changes right so you can 
 actually plug it inside some swift code 
 as you could see like the python 
 functions that we had in our script 
 now can be just called from swift 
 regularly with a little bit of help so 
 that you convert python objects into 
 swift native 
 data types 
 arguments from swift to python are 
 already automatically converted which is 
 awesome but the other way around you 
 actually have to be explicitly uh 
 casting right so you know you can do 
 changes to app behavior both by the user 
 but also by yourself so you could make 
 some stuff like you know some bundle uh 
 of code that you have on your website or 
 whatever and just update it without you 
 uploading to app store um is this is 
 this elegant maybe does apple love this 
 probably not but 
 do people do it like i don't know 
 facebook like yes they do 
 um 
 smart content templates so for example 
 if i create a new note but i'm in gym i 
 could have like a gym score note and it 
 will automatically pre-populate with 
 stuff that i should do today uh 
 or like level definitions in games like 
 this is in fact what like civilization 
 four used python for uh so you know you 
 could actually 
 just define uh levels uh using python 
 code which is nicer than just using 
 something that is static generating 
 music sequencing again like you know for 
 music just saying i want this note to 
 play after this note wait this much and 
 then play another note like plenty of 
 ideas that you now enable users to do 
 because you write an application in a 
 first class language but you enable 
 scriptability on the user end um so yeah 
 i could just go on but i'm out of time 
 two minutes so let me just say that what 
 we just accomplished was we ran python 
 311 which is in beta 
 that we build ourselves i didn't 
 actually build it right now because it 
 takes like 15 minutes for like all those 
 xcode stuff but like you know we use the 
 dot 8 files by make ios from python 
 apple support by beware uh inside a 
 swift ui application on an actual phone 
 as you could see with no objective c 
 boiler plate needed so it was all swift 
 uh 
 and this would not be possible without 
 the help of 
 russell keith mcgee who made b where 
 happened so huge help uh from is and 
 like i love the guy thanks uh corey 
 benfield actually helped me convince the 
 swift compiler to statically 
 link with python.a without him this 
 would be a theoretical talk this was a 
 practical thought thanks to corey who 
 works at apple now on swift on the 
 server side um ray wenderlich taught me 
 uh ios like those are very good 
 tutorials that you know are kind of 
 directed towards people who are new to 
 programming but also are not super 
 annoying to people who already know some 
 other programming language so 
 recommended 
 pedro jose pereira vieto wrote python 
 kit thanks to him 
 ned dealey takes care of mac os and 
 python including installers that you 
 know people are using when they are 
 downloading mac os 
 binaries from python.org 
 lawrence dana helps bootstrap apple 
 silicon support that we just used back 
 in python c python 3.9 so he actually 
 isn't was an apple employee at the time 
 and you know contributed this to us so 
 thanks to him and ronald osran wrote pi 
 objective c which is kind of the 
 precursor this granddaddy of you know 
 connecting max and python 
 and helped bootstrap apple silicon 
 support by reviewing and making his own 
 changes as well so thanks for all of 
 those my name is lukas langa thanks for 
 coming 
 i hope you liked it 
 thanks very much lukas for that great 
 talk 
 uh we have two minutes time for 
 questions so let's see uh do we have any 
 questions from the audience 
 um 
 hi great talk uh just a quick question 
 your dummy function um please link 
 python is that still needed at this 
 point when you've imported this it is 
 still needed like ideally we will have 
 like a more elegant way like of forcing 
 linkage for example by python kit 
 actually doing something but like you 
 need to convince the swift compiler that 
 python is needed what python kit is 
 doing it is actually like just uh 
 trying to find symbols inside your 
 binary but dynamically by dlcim so 
 within the code of your application it 
 doesn't look like you need python.age so 
 you need to really just force it somehow 
 can we have the next question please 
 thank you for the talk uh i was 
 wondering about uh if you can pip 
 install things on ios and especially the 
 binary package 
 no not in this way of embedding yes in 
 pytho but also now uh so there's this is 
 really a long question so like very 
 short answer uh we could make pip work 
 for pyth pure python dependencies so 
 that they could install into some local 
 storage and you could import them with 
 some python path um angling that would 
 be possible for stuff that has any 
 binary packages you need to either 
 compile the 
 dynamic libraries yourself because you 
 need to sign them yourself otherwise ios 
 won't enable you to uh 
 you know kind of load the dynamic 
 library you will have to do it yourself 
 uh or just actually include it in the 
 static binary as python is doing python 
 is also including everything inside a 
 single binary because it's just kind of 
 uh it's it's more i don't know like it's 
 it's a sure way that like the thing will 
 work so yes like ios now allows you for 
 dynamic libraries but you need to sign 
 them yourself so wheels from pipi they 
 cannot work because they're signed by 
 somebody else or as is the case now 
 they're not signed by anybody 
 thank you and we can do another short 
 question 
 it's really impressive to see python 
 running on ios um do you know what 
 performance is like compared to running 
 on say macos uh laptop silicon 
 yeah uh performance is better than on 
 intel max 
 it is weird but like 
 um m1 in particular but also like those 
 like a processors are predecessors of m1 
 is very highly optimized for automatic 
 reference counting which is part of 
 swift and it just so happens that python 
 also uses reference counting everywhere 
 so like for some reason like python is 
 pretty quick there obviously it is like 
 an order of magnitude slower than swift 
 because it is using an interpreter loop 
 to interpret your code in real time that 
 is kind of the point because we're 
 providing this code on the user level 
 right like we could make like an edit 
 box and the code could be really 
 provided by the user um but it's still 
 faster than intel max like you know it's 
 it's it's pretty impressive 
 thank you so thank you very much that's 
 all the time we have now please give 
 another round of applause to lukas 
 and we will be back in five minutes 
 thank you 
 testing one two three can you hear me 
 okay welcome back 
 as you all know the european this year 
 is a combined live and remote event 
 and i'm really happy to remotely 
 introduce the next speaker all the way 
 from australia we have keller patting 
 he has been a pythonista for 20 years 
 and is a principal software engineer at 
 capisce and he wants to talk about why 
 python 
 is slow so 
 please 
 let's have a welcome round of applause 
 for khalib 
 hi 
 hello to europayton and thank you for 
 attending my talk i think the organizers 
 have done an amazing job on this i was 
 just watching luciano in the other 
 session before this talking about typing 
 and i really felt like 
 i could at least in a small way be part 
 of the conference 
 so thank you again to the organizers 
 i have quite a few slides to get through 
 so i'm going to be speaking fairly 
 quickly and i don't think i'll have a 
 lot of time for questions at the end but 
 if you have any questions please email 
 me or contact me on 
 twitter the topic of my talk is why is 
 it slow we see many talks over the years 
 focusing on how to improve performance 
 in software but we don't see very many 
 talks about how to go about analyzing 
 performance problems or figuring out 
 why is it slow 
 a little bit about me as you heard an 
 introduction i'm an engineer at capisce 
 capiche is a natural language 
 processing company and we're trying to 
 solve the problem of how to analyze 
 customer feedback at 
 scale i've 
 made a learning cycle video course a 
 couple years ago in 2016 which is still 
 pretty relevant today very few people 
 know that it exists because it's only 
 really available on the safari platform 
 at o'reilly 
 and recently i also wrote a book on 
 async io 
 the goal of this talk 
 what i really want to do is to try to 
 give you a little bit of my experience 
 over the years trying to solve 
 performance problems i really want to 
 try and give you a strategy for how to 
 approach the problem 
 i want to give you a little bit of 
 structure for how to think about how to 
 approach this problem in different 
 scenarios but i'm not going to be 
 talking at all about how to actually 
 make things faster or any kind of 
 low-level diagnosis hardware issues cpu 
 registers and cache and and so on 
 so the scope of my talk is i've broken 
 up into four sections the first section 
 is going to be on fundamentals what you 
 really need to be thinking about when 
 tackling a new performance issue 
 in section two we'll talk about what you 
 can do when it is easy to run the code 
 when you can run the code over and over 
 again in your dev environment 
 and you really have a great deal of 
 freedom in how you tackle analyzing the 
 problem 
 in section three we'll talk about when 
 it's not quite so easy to run the code 
 and some strategies you can use there 
 and in section four we'll talk about 
 distributed systems and microservices 
 and how your thinking needs to change to 
 approach that kind of scenario 
 so let's jump right in 
 okay section one fundamentals 
 there's really only one fundamental that 
 i want to drive home in this talk today 
 the most important thing the most 
 important thing that you need to obtain 
 when analyzing a performance issue is 
 when the system is being slow what is it 
 trying to do 
 not in a fine-grained detailed way but 
 in an overall way you really want to 
 understand what the whole program is 
 trying to do 
 while you're having this performance 
 problem 
 and i really want to emphasize that very 
 importantly 
 it is super easy when analyzing 
 performance to try to focus on one 
 particular function or one particular 
 line and try to optimize just that thing 
 but by doing so you miss out on a whole 
 bunch of enormous performance 
 opportunities where by changing slightly 
 the design of the program you can get 
 massive boost in performance 
 so i'm going to emphasize that again you 
 want to figure out what is the code 
 trying to do while it is being slow yeah 
 and you have to look beyond the current 
 line of current function this knowledge 
 gives you the biggest leverage to be 
 able to make a huge impact 
 you'll often discover in practice 
 that when you find the cause of a 
 performance issue 
 that code can very often be producing 
 the same result over and over like for 
 example it might be an initialization 
 in the modern age with all these machine 
 learning models sometimes we find that 
 model initialization happens over and 
 over again 
 at the startup of a program 
 and sometimes you are able to save that 
 result in case it and just reuse it 
 again 
 on subsequent startups 
 but the best outcome and this happens 
 disturbingly often is that sometimes 
 when analyzing performs a problem you 
 find that a slow path in the code is not 
 even required 
 it may be there because of legacy 
 reasons it may be that previous people 
 in the team worked on the code several 
 years ago and they're no longer in the 
 team and no one really quite knows what 
 the code does but when you discover such 
 an opportunity you can get a huge 
 performance boost simply by deleting 
 that code 
 the best optimization you can do is not 
 to run a certain line at all and this by 
 far beats any kind of algorithmic 
 improvement 
 if you only focus on micro optimizations 
 it's easy to miss the really big wins 
 so long story short 
 really the the concrete thing that you 
 want to obtain when analyzing a 
 performance issue is you want to get the 
 call stack this is key 
 while the program is being slow you want 
 to see the line that it's currently busy 
 with or the functions currently busy 
 with as well as the entire call stack 
 all the way from how you got to that 
 line in the flow of the program 
 you want to know what initiated the slow 
 code and why because this gives you the 
 the leverage to be able to make 
 strategic design changes 
 so before we get into more concrete 
 details i want to talk a little bit 
 about tools if you search for 
 python performance tools you will find 
 many many results and these stretch all 
 the way back the past 15 15-20 years 
 there are many tools in the space but 
 for me personally my focus in this talk 
 is to 
 give you a short list of the things i 
 personally use 
 at work and in my personal projects and 
 my criteria for what i choose to use 
 really tries to maximize the product of 
 simplicity and impact 
 it has to be easy to use and it has to 
 be easy to get results quickly because 
 it's really easy to get bogged down in 
 very complex tooling where you don't 
 really get a lot of bang for buck 
 and by using some of those sophisticated 
 tools 
 and the final tip i'll give you in this 
 section is 
 um 
 instead of choosing the latest and 
 greatest tool and then finding out what 
 you can do with it it is much better for 
 you to first decide on the kind of data 
 you want the tool to give you and only 
 then select the tool that can give you 
 that data 
 so i've already told you that what i'm 
 really interested in is the call stack 
 so i tend to focus on tools that can 
 give me that 
 so here's our first concrete section 
 when the code is easy to run and you 
 have all of your tools available at your 
 disposal you can run it on your dev 
 machine 
 and you can throw many strategies at the 
 problem 
 what is my go to for how to approach 
 that scenario 
 local code is easy to run 
 you can run the program as often as you 
 like sometimes you do have to rearrange 
 things 
 but having tests makes it really easy to 
 to run different parts of your program 
 independently 
 so that's really key tests are not only 
 about trying to prevent regressions 
 but they also help in performance 
 analyses because the discretization that 
 tests provide can also be used for 
 performance analysis 
 for example if you're using the pi test 
 test runner 
 you can use the dash k parameter to 
 specify a particular keyword that will 
 narrow the scope of the tests that you 
 run 
 and i have frequently created tests 
 specifically to analyze a performance 
 issue not even intending to commit 
 those tests as part of the version 
 control system but only so that i can 
 invoke it using pi test 
 and pi test plugins which we're going to 
 get to in a couple of slides 
 so my first big trick is something that 
 you may not have 
 come across before but the idea is that 
 you can just use ctrl c as a performance 
 analysis tool 
 this is by far the best bang for back 
 that you're going to get 
 the idea really is you run your program 
 and while it's being slow you simply hit 
 ctrl c 
 what you are immediately presented with 
 is a stack trace 
 and the strikes the stack trace tells 
 you what your program was doing while it 
 was being slow 
 in particular if you have a big skew 
 in the code that is fast on the cast and 
 the code that is slow when you get the 
 stack trace after hitting control c you 
 almost always see the same trace 
 because 
 that body of code is consuming most of 
 the time 
 mike dunleavy has quite a detailed stack 
 over for a post about this and he calls 
 it stack sampling if you're in a hurry 
 and you can manually interrupt your 
 program under a debugger there's a 
 simple way to find performance problems 
 you just halt it several times and you 
 look at the stack trace if there's some 
 code that is wasting some percentage of 
 the time say 50 or whatever that is the 
 probability that you're going to see 
 that stack trace 
 that gets shown after you hold the 
 program 
 this seems like it's too simple to 
 actually work but in fact it works 
 surprisingly well and in exchange for 
 very little cost 
 to you up front 
 i'll run through a quick example and i'm 
 going to be moving pretty quickly here 
 because 
 i did a run through earlier today of my 
 talk and i ran out of time so i don't 
 want to spend too much time on this i'm 
 really going to try and just hit the 
 high notes on the concept 
 here i have a fake program that does a 
 few silly calculations there are three 
 functions f1 f2 and f3 and in the main 
 function we simply call those three 
 what we're going to do is we're going to 
 run this program and we're going to find 
 that it takes about two seconds to run 
 which is a little longer than we think 
 it should based on the complexity of the 
 code we're going to try to use our 
 approach of hitting ctrl c during the 
 two seconds 
 and then we're going to see what happens 
 so what in fact happens is we do get a 
 stack trace and this is the stack trace 
 that we get 
 and what you can see here is that we can 
 follow the stack trace all the way down 
 from the main function which is the top 
 of the stack 
 to where 
 the function is being slow so all the 
 way to the bottom here in f1 
 and in fact this function really does 
 take most of the time it's a fibonacci 
 number calculation which is very 
 recursive in nature 
 and the interesting thing about this 
 approach 
 is that regardless of when you actually 
 hit control c during those two seconds 
 you get the same stack trace every 
 single time 
 it doesn't even matter what the call 
 order is in our main function if you 
 call f1 f2 a3 or in reverse order f3 f2 
 and f1 you still get the same stack 
 trace back and the reason for that is 
 that f1 consumes all of the runtime 
 in this 
 city program 
 and this technique works surprisingly 
 well in a large variety of these these 
 ad hoc situations where for example you 
 have 
 a pie test invocation that seems to take 
 longer than it should 
 you can use this technique hit ctrl c 
 and you will often find that you may 
 have a fixture for example that is doing 
 a lot of expensive initialization early 
 on 
 so this is a really cheap way of 
 discovering 
 a performance bottleneck 
 compared to c profile for example 
 i want to highlight the cost of not 
 having a stack trace 
 the same program 
 run under c profile produces this output 
 it is true it does highlight the fact 
 that it is our f1 fibonacci 
 calculation that is taking all the time 
 and it also highlights that it has a 
 large number of calls but what we don't 
 have 
 in this output is we don't have the 
 relationship between f1 and main 
 these calls will just appear in whatever 
 order they sort according to the total 
 time and the per call time 
 and so on 
 so we lose that link 
 so it's easy to see the time span or the 
 number of calls spent but not why not 
 why that call was being made 
 the other thing to keep in mind is that 
 c profile is quite expensive to run 
 for this particular dummy program that 
 i'm using here the original run time was 
 two seconds but when you run an ic 
 profile it was 74 seconds 
 in larger more complex systems 
 that impact can really burden you when 
 you're trying to figure out the 
 performance behavior of the system 
 so just to summarize see profile is 
 pretty expensive 
 it measures everything even things 
 you're not really interested in 
 and the worst thing is that 
 that table that we just saw when you see 
 the numbers presented in that way it 
 feeds the temptation to want to focus on 
 a micro optimization because you see 
 that a particular function is being slow 
 and that breeds the temptation to want 
 to make that function run faster rather 
 than thinking about the design of your 
 entire software stack 
 however c profile redeems itself because 
 it does actually collect the information 
 we need it just doesn't automatically 
 expose it in its default output 
 so 
 another neat trick 
 and the second and final one in this 
 section is pi test profiling which is a 
 pi test plugin 
 so the key thing is after you install pi 
 test profiling 
 this 
 command line parameter dash profile svg 
 is really the magic it's very easy to 
 configure if you have a pisces suite and 
 and call that 
 and when you do that 
 uh what you'll see printed in the 
 console output is this svg file that's 
 been 
 created that svg file looks something 
 like this it gives you a large map of 
 nearly all the functions that got run 
 during the execution of your tests 
 and it has a color coding for the cost 
 so the warmer the color the more costly 
 that function call is 
 and 
 the colder the color the less costly 
 and i'm going to zoom in on a diagram 
 like this very quickly 
 it also gives you some of the stats that 
 you get usually in c profile output like 
 for example it gives you 
 the total time and the own time that was 
 spent just in that function but it also 
 gives you the call stack because these 
 arrows show the relationships between 
 all the function calls so you can use 
 those two pieces of information to um 
 gather quite deep insights about the 
 performance behavior 
 of your system 
 however bear in mind this is a lot more 
 expensive than control c because it user 
 c profile and c profile is slow 
 okay we're about halfway through i think 
 i'm doing quite well for time 
 so the previous section was when it's 
 easy to run the code locally in this 
 section it's more complicated 
 some reasons might be that the code that 
 you're trying to analyze makes a lot of 
 use of threads and sub processes it 
 might be difficult to run a narrow part 
 of the program 
 or you may not know which part to run 
 you may find in a particular scenario c 
 profile is too expensive to run 
 you're just not getting feedback fast 
 enough after making changes 
 and finally you may have significant 
 code in native extensions and c profile 
 doesn't highlight 
 any information inside those 
 so 
 my go-to in these scenarios when the 
 simple tricks no longer work is a really 
 magical tool called pi spy 
 it really is impressive i have here with 
 these green check marks basically 
 you know a wish list of all the features 
 that i've wanted in the past before i 
 found pi spy about things that it can do 
 it's a sampling profiler it can attach 
 to a running python process 
 so for example you could use it in a 
 production environment 
 if 
 a process seems to be 
 hung or in a frozen state you can attach 
 it and get get feedback 
 it has a very low speed impact it can 
 analyze sub processes it can dump call 
 stacks on command which we'll get to 
 shortly 
 and it can also include 
 stack trace information from native 
 extensions inside interleaved inside the 
 same 
 python extensions you would be used to 
 seeing 
 so let's have a bit of a look at pi spy 
 it has three sub commands 
 um the three sub commands are record top 
 and dump and we'll just take a quick 
 look at each of those 
 so 
 the way to invoke it on the command line 
 is it it has a cli called pi spy and 
 then the sub command which would simply 
 be record 
 and in this case you can see just like 
 we saw previously it's going to dump an 
 svg file 
 and you can also add the dash desktop 
 processors command 
 which will also measure sub processors 
 so what that produces is a flame graph 
 that looks roughly like this 
 i'm not going to go through this in 
 detail but i just want to give you a 
 sense of what you can obtain with this 
 tool 
 in practice you can hover over each of 
 these worms and you get additional 
 information and metrics 
 and you get that 
 information about which function calls 
 are being made from 
 which other function calls and their 
 duration based on the width of each of 
 these bars 
 okay moving on so pi by top it gives you 
 a view very similar to the unix top 
 command 
 but instead of seeing processes what you 
 actually see is 
 functions and file names in your running 
 python program 
 as they consume more or less time 
 they'll change 
 their order 
 inside these columns 
 and on its own this isn't that 
 convenient because you're not really 
 seeing a stack trace you're just seeing 
 a measurement but it is super convenient 
 to be able to just attach this to a 
 running process 
 in certain situations and then getting a 
 very quick sense of which line the 
 current program is is stuck on 
 um and this final command dump this is 
 the one that is really useful 
 so again you have a sub command called 
 dump and you attach it to by pid to a 
 particular running python process 
 and then what comes out is a list of all 
 the threads with the call stacks from 
 all the threads in that running python 
 process 
 and as i said you can produce it on 
 demand 
 so you can execute your program or you 
 can have a program running in a 
 production environment and you can 
 attach this with the dump command and 
 then get an immediate snapshot of what 
 all of the threads are busy with 
 this is super amazing for being able to 
 jump in and get performance metrics 
 really quickly without very little 
 ceremony 
 and finally i just wanted to highlight 
 some other features that the pi spy dump 
 command has 
 it can show local variables and include 
 them within each frame in those call 
 stacks that i that i showed in the 
 previous diagram 
 and 
 you can add the native parameter to 
 include call stacks from native 
 extensions 
 those do need to be compiled with an 
 additional flag and that is documented 
 inside the pi spy documentation 
 but 
 that is how you can 
 have your call stack from python and 
 from your native extensions interleaved 
 together in that live dump view 
 okay and finally we're on to the final 
 section and this is the most difficult 
 one 
 in fact it turns out this is the easiest 
 one after all because you don't have 
 very many options to get good 
 information there's really only one path 
 to go down 
 just to clarify what i mean by a 
 distributed system 
 you have a bunch of services running 
 perhaps and a bunch of computers that 
 are making network calls between 
 themselves and the lifetime of each of 
 these services running on the different 
 computers is all different and they 
 deploy differently and so on 
 but they do work together to provide 
 some overall service 
 they are much more difficult for you to 
 be able to run code at will unless you 
 have a very small 
 system 
 services depend on other services and 
 those can also depend on other services 
 so it's even difficult just to reason 
 about the system architecture usually 
 and setting up a full dev environment 
 for such a thing can be hard or even 
 impossible 
 and worst of all the performance 
 behavior can be non-deterministic where 
 the slow behavior can only happen 
 sometimes like maybe when only one user 
 does something or 
 maybe when only one kind of file is 
 being processed by a software and 
 something like that 
 nevertheless the same rule applies the 
 golden rule 
 the fundamental thing that we wanted 
 even in the simpler cases was that we 
 wanted a call stacks because we wanted 
 to reason about what the entire system 
 was doing when we were observing slow 
 behavior 
 in this case though what we really want 
 is a call stack that operates across 
 distributed network services right 
 we want to know which servers called 
 which are the service and how long each 
 of those calls took and we would ideally 
 like to see that 
 in an audit relationship like a tree 
 distributed tracing provides that call 
 stack and it gives you timings for each 
 of those pieces 
 um i have a definition here which 
 i've stolen from honeycomb 
 it's a technique used to monitor and 
 observe requests as they flow through 
 distributed services 
 distributor tracing provides visibility 
 into each request and all of its 
 subsequent parts 
 there is an industry standard that has 
 been built up around these ideas 
 called open telemetry and i have the 
 link here 
 there are many vendors that provide 
 tools that do this but at capisce we're 
 using honeycomb and i'm going to use 
 honeycomb in a couple of examples 
 so the key thing that you get from a 
 distributed tracing 
 tool is a view like this you get a tree 
 on the left so right at the top here our 
 trace begins from a django endpoint 
 which is the entry point into our system 
 from a front end 
 like a react or a view 
 front end 
 application 
 and from this point on that django 
 system is going to service is going to 
 call other services in order to 
 accomplish some goal so i've highlighted 
 here in red we can see that the service 
 name changes throughout the call stack 
 and in this example that i'm showing 
 here we have three services 
 but it can be more can be less 
 and these time-based bars that run 
 across tell you how long 
 that particular step 
 was consuming 
 and you can see these layered in a 
 nested fashion 
 there is a cost though for all of that 
 power 
 the cost is that this data needs to be 
 collected continuously you can't just 
 turn it on in an ad hoc way as we saw 
 with other tools 
 you have to add add instrumentation to 
 your software and all of these trace 
 events have to be transmitted to in my 
 case the honeycomb servers 
 so that they can be rendered on demand 
 to set up such things is fairly 
 straightforward 
 you typically would initialize the 
 system 
 by providing an api key which you would 
 get from the service 
 and for things like django and flask and 
 other similar frameworks fast api there 
 is a middleware that can automatically 
 be configured to integrate into at least 
 the the rest api part of the stack 
 and then inside your code you have to 
 add additional things like this for the 
 case of honeycomb they have this b line 
 and client library 
 which gives you two main tools to work 
 with the one is a decorator that you can 
 attach to functions and the other one is 
 a context manager that you can use to 
 scope discrete blocks of code 
 and those two things work together to 
 send these trace events to honeycomb 
 i have a quick example of a case study 
 here that we really did use at capisce 
 where customers upload 
 spreadsheets which contain customer 
 feedback data and then we process and 
 analyze those and this screenshot is in 
 fact taken from 
 a real issue on one of our 
 issues in the issue tracker where we 
 were trying to process a csv final was 
 incredibly slow 
 and 
 this might be too small to read but this 
 first big bar at the top is about 
 encoding detection 
 literally just trying to detect the text 
 encoding of the uploaded file and the 
 second one is to generate a csv schema 
 from the uploaded file 
 and we found that we had a really 
 problematic code path that was producing 
 very slow results 
 and from 
 when this issue was reported to the 
 resolution of the issue was within one 
 workday because we had these traces 
 available and i could immediately jump 
 to the tracing honeycomb and immediately 
 see that we had not one but two separate 
 problems 
 and we were able to fix both of those 
 and resolve it really really quickly 
 distributor tracing is extremely 
 powerful and i have a confession to make 
 i use this tool even during software 
 development just when i'm writing a new 
 feature or i'm working on a bug because 
 all the code is already there the 
 instrumentation is already in my 
 software so as i'm writing new code i 
 just configure a 
 an environment on honeycomb for myself 
 for personal use and then i send events 
 to that and i can analyze the 
 performance even during my development 
 process using those really nice graphics 
 in particular in dave i trace all of the 
 sql queries especially for django and 
 for the django orm because it's really 
 easy to emit way too many 
 sql queries if you're not careful about 
 how you control the execution of those 
 queries with nested models and so on 
 okay so in summary 
 remember my advice is what you really 
 want to get when trying to figure out 
 and analyze a performance problem and 
 you're coming to that problem from a 
 blank slate what you're really trying to 
 get is a call stack because you want to 
 see what is causing the program to be 
 slow through the entire stack right from 
 the from the side of the program 
 when possible 
 do give control c a try 
 if you have something that is running 
 slow on your machine and you want to 
 figure out what is making it be slow hit 
 that control c and you can get an 
 immediate stack trace and try to make 
 sense of what's happening 
 if you need a bit more detail than that 
 if that's producing confusing results or 
 you have multiple issues that you're 
 trying to figure out pi test profiling 
 is a much more comprehensive approach 
 which will give you that large tree of 
 of of svg that you can use to 
 check the performance of many functions 
 at the same time 
 if you have special needs where you 
 can't run the code 
 that will 
 pi spy is a really great tool to be able 
 to attach to a running python process 
 and it makes very very little 
 performance impact 
 on that running process but can give you 
 real-time information um including 
 cumulative stats through the top command 
 and the dump command can also give you 
 call stacks from all the sub threads in 
 real time 
 and finally 
 if you have a distributed performance 
 issue where it's 
 quite difficult to isolate the code to 
 to a single system 
 you will have to use a tracing system 
 like honeycomb to be able to analyze 
 performance and that will require 
 upfront instrumentation of your code in 
 order to emit those events 
 i know that i have left out a huge 
 number of tools and i'm sure 
 other people would have their own 
 suggestions 
 for what 
 what will work well for them 
 but this is the set that i currently use 
 so these are my go-to options for the 
 different scenarios that i've 
 highlighted 
 and that is the end of my talk 
 thank you everyone for attending 
 thank you very much caleb for sharing 
 your tools and all these inspiring tips 
 for us we have a 
 short amount of time 
 and 
 since this is a remote 
 event let's check if we have a remote 
 question 
 i see something no okay then we also can 
 have local questions if somebody in the 
 audience has one 
 if you do we have a microphone over 
 there where you could go and ask one 
 and 
 let's see if i see a question 
 i do not 
 i see somebody running through the 
 microphone please go there quickly thank 
 you 
 hiya thank you for this work yeah a bit 
 closer closer yeah right so uh thank you 
 for your work uh for your um for your 
 talk um so my question is with regards 
 to this tracing systems you mentioned 
 honeycomb are there any other 
 alternatives 
 that you know of that we can check out 
 many there are many if you if you just 
 google distributor tracing you'll find 
 many of them there are also open source 
 systems that you can self-host 
 but off the top of my head 
 jagermonkey is one uh datadog provides a 
 system i think century now also is 
 provides distributed tracing and 
 i say that perhaps under correction but 
 but there are many and new ones are 
 coming out all the time so probably 
 what's better for you to search is not 
 distributed distributed tracing but open 
 telemetry 
 that's really the key thing because 
 many vendors have 
 joined forces to decide on a common 
 interoperation protocol 
 for distributed tracing so that's that's 
 the thing to look up is open telemetry 
 all right thanks 
 so thanks for your question and that's 
 about all the time we have so let's have 
 another round of applause for kelly 
 [Applause] 
 and let's let's hope that we see you at 
 another euro python in person so thank 
 you again i wish i could have been there 
 okay so we'll take a five minute break 
 and then continue with the next talk 
 okay thanks everybody to come for coming 
 back to the last talk of this block 
 we have with us today leonardo giordani 
 who's the author of the book clean 
 architecture and python and he has a 
 talk with the same title please enjoy 
 thank you martin 
 thank you for being here 
 so the title of my talk today is clean 
 architectures in python a tale 
 of durability utility and beauty 
 and my goal today is so i'm here because 
 i want to share 
 my views on 
 system design 
 give you an example of what i discovered 
 and what i learned and maybe meet people 
 who are interested in 
 system design as well 
 so this is me well not a picture of me 
 uh 
 but you know i'm a developer and a 
 blogger 
 you are welcome to visit my blog i 
 usually write about python obviously 
 tdd object oriented cryptography and 
 infrastructure these are the main things 
 i like to write about 
 so today it's a talk about the clean 
 architecture and i want to start 
 with a question thinking a bit about 
 what architecture is 
 we mentioned architecture many times the 
 architecture of a system or what is it 
 what is it definition 
 so i found this um in a book 
 that has been around for a while the 
 architecture 
 it's it means about architecture 
 it's been written a couple of thousands 
 years ago 
 the true views who was 
 a roman architect and engineer 
 says that architecture is about firmitas 
 utilitas and venustas 
 which translated in modern english is 
 durability 
 utility and beauty 
 so 
 vitruvius says that architecture is 
 about things that are durable 
 something that has to last 
 has to be useful 
 has to be beautiful 
 and for me this was very interesting 
 because 
 how many time 
 do you think about your code as 
 something that has to be 
 useful beautiful and durable 
 useful yes nobody wants to write 
 something that is useless 
 but what about 
 durable 
 we change framework every two years now 
 right or every six months i don't know 
 so having something that lasts 
 and beautiful that's the thing i'm 
 mostly concerned about 
 it's interesting let me mention this 
 that vetuvius was an engineer and an 
 architect 
 and 
 these two professions don't go 
 together that much nowadays 
 it's interesting to think that engineer 
 the word comes from engine 
 but engine 
 comes we when we discuss about engines 
 we think about something mechanical 
 but engine actually comes from um 
 ingenuity 
 in latin 
 it's from cleverness so it's less about 
 mechanical things is more about 
 solving a problem in a clever way 
 anyway 
 i went on and i checked also on the 
 dictionary modern english dictionary and 
 i found these two interesting 
 definitions of architecture 
 one is the art and science of designing 
 and making buildings 
 and the second one is more 
 concerned with computers and it says the 
 internal organization of computers 
 components with particularly the 
 reference to the way in which data is 
 transmitted i like these two definitions 
 i wanted to come up with something a bit 
 more compact 
 so i try to merge them into 
 this which is the art and science 
 in which the components of a computer 
 system are organized and integrated 
 i want to stress 
 art and science 
 how many times do you think about what 
 you do daily as art and science 
 as science yes data science computer 
 science 
 the mechanical part right 
 what about art 
 when do you look at your code and think 
 this is art 
 why why is it not data art or it's not 
 computer art not as in you know painting 
 something with the computer but our code 
 is beautiful or it can be 
 and the other two interesting words here 
 are organized and integrated because 
 a system architecture when we when it 
 comes to computer science is all about 
 where 
 components of the system are and how 
 data flows between them 
 so this is the integration part 
 now that i 
 defined architecture 
 the following question is 
 do we need it 
 so do we need things 
 our code to be useful durable and 
 beautiful 
 and this is up to you i'm positive about 
 this otherwise i wouldn't be here but i 
 want to give you a couple of 
 examples and one comes from the 
 traditional architecture and it's 
 the bridge that is in front of this 
 building the samuel beckett bridge 
 it's interesting i was looking at it 
 these days and i thought 
 does this bridge have to be shaped like 
 a hub 
 if the requirement of the bridge is just 
 to take cars from one side to the other 
 it doesn't have 
 you just need a plain bridge right 
 something that i could design because i 
 don't know anything about which design 
 but 
 if the requirement is to make your 
 journey better 
 well being shaped like a harp 
 in dublin 
 is a nice thing to have 
 so 
 this is food for thought maybe you know 
 like what is the requirement of your 
 code what what is it that you are 
 creating when you create a library do 
 you just create some machinery or do you 
 create something to make the journey 
 better 
 the other example i have it's about 
 something lasting 
 a long time um 
 the unix system it's an operating system 
 was designed in 71 so 50 years ago 
 and it was well thought 
 not everything in a unique system is 
 perfect okay sometimes it's far from it 
 but it was well thought 
 so well designed that i am running a 
 linux machine and linux is a clone of 
 unix 
 and many of you use macos which is a 
 derivative of unix 
 50 years 
 so again how many times do you look at 
 your code the code that you write and 
 you think 
 in 50 years people are still we will 
 still 
 use this code or at least these ideas 
 anyway i'm not the the only one who 
 thinks that system design is an 
 interesting thing 
 there are much smarter people than me 
 who wrote a lot of books vast literature 
 about this i selected five books that i 
 read which i believe are interesting 
 about the topic 
 some of these are 
 door stoppers pretty thick okay so if 
 you are not up for the challenge i 
 recommend retrieving at least the two in 
 orange so design patterns and enterprise 
 integration patterns 
 at least 
 read the introduction 
 and i'm not joking the introduction to 
 these two books the two introductions 
 are 
 short 
 but they give you a narrative 
 of the challenges 
 and some of the solutions that you might 
 have when you design a system 
 and i was 
 i was really 
 you know 
 flabbergasted when i read the 
 introduction to design patterns because 
 it was like hey i faced these issues 
 every day 
 i want to mention another thing about 
 enterprise integration patterns this is 
 a book about messaging 
 message based systems more about 
 distributed systems if you want 
 but it's interesting that 
 message based systems microservices for 
 example 
 this software design 
 and languages 
 they are all in the same league they 
 share a common 
 trait 
 which is 
 messages 
 object-oriented programming and you can 
 quote me on this 
 is supposed to be 
 about 
 objects that exchange messages 
 so every time you call a method on an 
 object you are sending a message to 
 something 
 so it is a distributed system 
 and if you if you think about that if 
 you when you code in python if you think 
 about messages this might not change the 
 code itself because you are still 
 calling methods 
 but it will definitely change the way 
 you think about your code 
 it's a bunch of objects it's a 
 distributed system and i'm exchanging 
 messages anyway this might be for 
 another talk another time 
 now that i defined 
 architecture and i decided for you that 
 we need it 
 let me define clean because this is 
 about a clean architecture and 
 i find it 
 easy to define the opposite of clean 
 the picture in the background 
 if you look at that system 
 you can definitely say this is not clean 
 it's not tidy 
 good luck maintaining something like 
 that okay they said pull the green cable 
 yeah good luck okay 
 this is an extreme 
 example 
 probably but sometimes our code looks 
 like that 
 right you change something and suddenly 
 everything crashes nothing works anymore 
 instead in a clean system with a tidy 
 system if you want 
 you have um these 
 characteristics for for each component 
 you know the three w's right you know 
 where it is it's easy to find the 
 component in the system it's isolated 
 you know what it is 
 from the name for example and you know 
 why it is in the system you can say 
 why it's been included in the pictures 
 in the background there are two just you 
 know hardware systems um and they are 
 tidy it's easy to trace where our cable 
 goes 
 some are color coded so it's easy to 
 understand you know why they are there 
 what are what they are 
 doing okay now that i defined the clean 
 architecture 
 in terms of the words let's go for the 
 concept f1 example 
 so what is the clean architecture 
 it is a concept that was introduced by 
 robert martin uh some years ago robert 
 martin is a system engineer system 
 designer you know uh developer and i'm 
 not here to advertise robert martin's 
 work 
 mostly because robert martin is very 
 good at advertising himself you know so 
 um but i'm gonna use the same name 
 it's it's important for me to stress 
 that the concepts 
 that robert martin dubbed the clean 
 architecture 
 uh predate his work so they have been 
 around for a long while 
 so let's call it the clean architecture 
 but it's a set of concepts and 
 that predates what robert martin did 
 what is it it's a layered approach so 
 it's a way to structure your software 
 project right your your code 
 it's layered and it's circular 
 so in the traditional 
 [Music] 
 say 
 definition we have four layers you can 
 have more of them but these are the 
 traditional ones entities use cases 
 gateways and external systems 
 what happens is that when you create 
 something in a clean architecture this 
 something this component 
 will belong to one of these layers and 
 there are rules there is actually one 
 simple rule 
 one rule at least 
 which is that 
 um 
 your component 
 can see 
 i'm gonna define what c is 
 can see only what has been defined in an 
 inner layer 
 so if you create something in the use 
 cases 
 layer or ring 
 you can see everything that has been 
 defined in the same layer use cases and 
 everything that has been defined in 
 entities you are not allowed to use to 
 access anything that has been defined 
 outside 
 and that that has to do with 
 dependencies 
 the problem of unclean systems 
 remember the cables before 
 is dependencies between 
 components 
 when you have a component that depends 
 on other components and these other 
 components depends on other components 
 and you can't trace these dependencies 
 and sometimes they are circular 
 dependencies 
 in a clean architecture there are no 
 circular dependencies 
 the golden rule i'm going to introduce 
 it now and then 
 show you an example that clarifies it is 
 that you talk inward with simple 
 structures outwards through interfaces 
 what does it mean simple structures 
 are 
 data types 
 that have been defined 
 in inside so for example again something 
 in use cases can use data types and i 
 mean data types in python for example 
 you can instantiate them 
 if they have been defined in use cases 
 and if they have been defined in 
 entities 
 if something has been defined in 
 external systems you don't see it 
 you can't instantiate it 
 interfaces interfaces have to do 
 so they they are related to dependency 
 injection which is something i will 
 introduce later 
 what is an interface um 
 going back to what i said about objects 
 and sending messages 
 when you send a message to something you 
 expect it to be able to receive that 
 message when you call a method on an 
 object you expect that object to well 
 have that method right otherwise you'll 
 get an exception 
 in python we don't have an explicit way 
 to 
 state infrastructure in 
 interfaces okay to create them 
 even though we have now protocols we 
 have 
 abstract based classes there are many 
 ways to 
 work with interfaces and we can discuss 
 about this another time because there is 
 no enough time today 
 anyway i'm coming back to this slide 
 later when after the example 
 so the example today is simple 
 the code i will show is python it's 
 valid python 
 but i stripped all the you know error 
 checking a lot of things that are not 
 useful for now obviously the real 
 the real code is a bit more complicated 
 my use case 
 is to retrieve a list of items is very 
 simple 
 when do we want to retrieve a list of 
 items 
 no you have a social network and you 
 want to retrieve a list of posts right 
 or you are amazon you want to send you 
 to show a list of proper items that you 
 are selling 
 in this 
 example my use case is just a simple 
 function it exists in the use cases 
 layer 
 and for the time being it doesn't do 
 anything 
 then i define some entities entities are 
 models okay they 
 represent 
 real items that are in my business logic 
 so in this case for example something 
 with a code enterprise okay just a 
 simple class 
 that captures data encapsulates data 
 the entities live in the entities 
 layer and they are known to all other 
 components 
 it's 2022 so we probably want to build a 
 web application but this is not required 
 okay it's just an example 
 the web application um 
 requires a web framework because i don't 
 want to implement you know the logic to 
 deal with http requests and all these 
 things there are smart people who did 
 for me 
 in this case i'm using flask but i can 
 use any other web framework 
 the web framework exists in the external 
 systems and i want to say a couple of 
 things about this 
 i mentioned business logic before 
 the business logic is what you market 
 is the core of your application 
 the web framework is not generally 
 speaking part of your business logic you 
 are not marketing django you're not 
 marketing flask 
 you're marketing a social network you're 
 marketing items delivery whatever right 
 so it's 
 reasonable for the web framework to be 
 in a very external layer where we use it 
 but we don't 
 manipulate it 
 the core 
 the most important thing in a clean 
 architecture i would say in any 
 architecture is the business logic this 
 is what 99 percent of your time should 
 go any time use every time you spend you 
 know configuring external systems it's 
 not wasted but it's not given to the 
 core of your business 
 anyway this is the web application the 
 web framework 
 now what is the task of the web 
 framework 
 the web framework is there because it 
 wants it has to 
 translate 
 http requests into calls 
 this is all a web framework has to do 
 granted it's not an easy task okay there 
 are many things involved but this is 
 what the web framework should do 
 get an http request and 
 transform it into a call for example for 
 a python function 
 in this case this is exactly what i'm 
 doing i'm calling 
 the 
 use case which is a function 
 here you see that the web framework 
 communicates with the use case with 
 simple structures what does it mean 
 in this case i'm using request args for 
 the sake of 
 you know simplicity it's just a 
 dictionary 
 and it's a simple structure because it 
 has been defined in the in the language 
 right so it's 
 it might be an entity or it might be 
 something that the language defines all 
 these things exist in python so whatever 
 is defined in python as a core language 
 is available 
 so i'm sending 
 to 
 the 
 use case a simple structure something 
 that the use case can understand 
 for example i shouldn't send anything 
 that is defined in the web framework 
 some structure that has been defined 
 there a type that flask uses to manage 
 an http request because the use case 
 doesn't do anything doesn't know 
 anything about http request and it 
 shouldn't know anything 
 okay 
 then we have to retrieve items and data 
 data is stored usually in a repository 
 and we are used to think about 
 repository as a database which is what i 
 have in the example here 
 but i want to stress that a repository 
 is much more than a database for 
 starters it doesn't have to be a 
 relational database it might be no sql 
 mongodb for example 
 or it might be something different for 
 example a web api 
 it's a source of data right you call the 
 api you get data this is exactly what 
 you do with the database 
 it might be a bunch of text files which 
 is a rudimentary database 
 it might be a hardware sensor 
 that is a source of data 
 it's a repository okay so let's 
 think about it as a database i'm going 
 to say database probably a lot of times 
 but 
 the repository is the right 
 word here 
 and the database the repository exists 
 in the external systems 
 layer because again 
 it's something that is not part of my 
 core business it's not my business logic 
 in system design we usually call the web 
 framework the database everything that 
 is outside as a detail we call it a 
 detail 
 and many many times it surprises people 
 because they are like what detail i mean 
 configuring postgres you know and all 
 these things it's complicated it's not 
 it's not secondary it's not just so 
 simple 
 a detail 
 means 
 that it's not part of the business logic 
 this is not what i'm marketing 
 if my product works with postcards or 
 works with mongodb 
 you are not concerned you as a client 
 are not concerned 
 your problem is to receive a service 
 so this is why it is a detail 
 while the 
 specific algorithm i use for my 
 recommendation system for example is the 
 core business is what you like of my 
 product 
 okay so this is the difference between a 
 core 
 a business logic and the detail so the 
 database is a detail 
 even though it might be complicated 
 however it exists in the external 
 systems so as i said before the use case 
 is not allowed to 
 communicate directly with the database 
 in python firms 
 the use case is not allowed to 
 instantiate anything that is 
 tightly coupled with the database that 
 is connected with the database directly 
 because if i have code in my use case 
 something which is i don't know 
 postcards a library for to interact with 
 postcards or to interact with mongodb 
 i am 
 coupling my use case with the 
 implementation of the database 
 and this is not good because at that 
 point i have my core business my core 
 business logic 
 coupled with a detail which might change 
 my mind might not be the same thing in 
 time 
 so i create an interface this is um in 
 this case we are talking about python 
 it's an object that 
 provides a facade okay so a set of 
 methods that are common to databases 
 so 
 the web framework instantiates the 
 database interface or the repository 
 interface the web framework can do it 
 because it's in an outer layer so the 
 web frame sees 
 can see what's in the gateways 
 and passes 
 the 
 so it sends the in 
 instance of the postgresql in this case 
 to the use case 
 this is called dependency injection if 
 you are not familiar with the concept i 
 have a slide for that later but look at 
 it 
 the use case the code of my use case 
 doesn't have postgres or apple 
 hard coded in it 
 i'm receiving an object that provides 
 methods 
 that might be an object of postgres repo 
 mongodb repo type whatever 
 the important thing is the 
 interface 
 or the set of methods that that thing 
 provides 
 cool now internally i'm in the use case 
 now and i have finally my business logic 
 okay this is where my 
 brain 
 comes into play right i have to write 
 something that implements the 
 recommendation system the whatever 
 filtering you want 
 eventually sooner or later i have to use 
 the database interface to retrieve the 
 data so in this case i'm calling repo 
 list 
 passing the parameters that i received 
 from the http request 
 or from outside i should say right 
 where they come from is not important 
 the business logic might be for example 
 to prepare the parameters to 
 add some filtering you know or to do 
 something else 
 anyway back to the database interface 
 i'm calling repo list okay here repo 
 list so i'm in the database interface 
 now 
 and the database interface is tightly 
 coupled with the database that is 
 postgres repo so it's it has been 
 designed to work with postgres okay it's 
 in the name 
 so the two um communicate with a 
 specific language in this case i'm using 
 sql alchemy 
 it's an objective relational mapper but 
 eventually i'm 
 in um in a mindset of 
 querying a relational database this is 
 what i'm doing here okay i'm i'm 
 committed to 
 relational databases at this point and 
 this is what i'm doing so the two things 
 are tightly coupled 
 what the database interface does is to 
 as i said query the database 
 and then 
 it transforms the output of the database 
 the database just sends me values right 
 it's 
 sql so just 
 standard types known to sql databases 
 the database interface has the task to 
 convert those values into entities 
 because at this point 
 everybody can see entities as a layer 
 it's a very inner layer so the database 
 interface can say okay these sql values 
 that i get become 
 items 
 as in items that i defined 
 and these items are sent back to the use 
 case as a result of the repo list at 
 this point i can add more business logic 
 okay just to say that obviously if you 
 want to if you have to 
 call your repository you can do it at 
 any time and your business logic is 
 around that code is where you augment 
 these results okay with your algorithms 
 with your cleverness 
 your product 
 at this point the use case has 
 the 
 results 
 and it can send it back to the web 
 framework or to whatever called it 
 and the web framework so this is again 
 sorry entities the web framework 
 can 
 knows about entities so this can still 
 be 
 an entity model that i created 
 the web framework again has 
 one task that of converting 
 the entities which are specific models 
 of my 
 business into something that is 
 understandable outside for example 
 json 
 okay this is the task of the 
 web framework my use case doesn't know 
 anything about json doesn't care because 
 the use case is okay with entities it's 
 part of my business 
 this is the journey of the data in a 
 clean system at least in this example 
 in a clean architecture 
 i want to go 
 back quickly to 
 the initial 
 slide about the golden rule right talk 
 inwards through simple structures and 
 outwards 
 through interfaces have a look at this 
 code these are two different 
 possible implementations of a use case 
 the second one is the one i used the 
 first one is the incorrect one if you 
 want 
 why is it incorrect 
 it works 
 okay first of all so it's not incorrect 
 uh from that point of view 
 but this couples 
 my code the code of my use case 
 with the postgres repo it means that i 
 can't use anything else or if i want to 
 use something else i have to touch 
 the use case but the use case is your 
 business logic and it shouldn't be 
 touched because you change something 
 which is a detail 
 where you store data 
 okay 
 the second one instead and this is a 
 good example i hope of dependency 
 injection 
 is when you create something outside 
 and then you pass an instance of it 
 the instance 
 has been instantiated outside so 
 the part of the code that is coupled 
 with the 
 type the postgresql it's outside in this 
 case is the web framework your use case 
 just receives 
 an instance something that can accept a 
 certain set of messages does it make 
 sense i hope so 
 this is what 
 happens in a green architecture simple 
 structures inside interfaces outside 
 cool 
 i want to 
 tell you about the advantages of the 
 clean architecture why should i go 
 through all this pain 
 and there are two specific things i want 
 to mention 
 the first one probably the most 
 important one for me is testability 
 a clean architecture or software 
 designed with a clean architecture can 
 be tested very well 
 what do i mean by that um 
 look at the use case 
 i can easily isolate the use case from 
 the web framework and from the database 
 interface it's just an object that 
 receives a repo 
 and some parameters and returns some 
 results 
 so what i can do is to pass a dictionary 
 you know of parameters 
 a mock database interface so something 
 that pretends to be the database 
 interface but it's not connected with 
 any database it's just you know a mock 
 it returns a fixed set of data 
 and check that my business logic works 
 given that input gives some output 
 this allows me to test my business logic 
 in isolation 
 i don't need the database to test my 
 business logic i don't need the web 
 framework because these are details my 
 business logic is not about details 
 at the same time i can test the details 
 because 
 yeah details but they are part of the 
 implementation so i have to test that my 
 web framework works and the web 
 framework can be detached from the use 
 case 
 because the web framework the only task 
 is not a simple task again but the only 
 task of the web framework is to accept 
 http requests 
 convert them into calls 
 get the result of this code and convert 
 it back to an http response 
 as i said it's not simple i have to test 
 that this works and i can do it in 
 isolation 
 and last i have to test i can test my 
 repository interface this requires 
 the database because this is an 
 integration test okay i'm testing that 
 my the facade of the database works so i 
 i need a database running this might be 
 a slow test you know that you might run 
 just sometimes 
 again 
 i want to stress this i see it too many 
 times when we when it comes to testing 
 in particular with web frameworks 
 we end up 
 testing the database 
 so we store a model then we retrieve the 
 model and we say yeah it works 
 thank you very much this means that 
 django or whatever framework you're 
 using 
 works that postcards works but this is 
 not what you are supposed to test 
 these are 
 you know provided by a third party is 
 not part of the occult business 
 the second advantage 
 is about 
 [Music] 
 customization i would say 
 look at this in this case i have two 
 different use cases one is 
 two list items and one is to list users 
 a phone for some reason for example for 
 performances reasons 
 i stored the users in a db which 
 is not relational okay so i can't use it 
 with a sql alchemy for example because 
 it's not sql 
 but this is not a problem in a clean 
 architecture because my use case is 
 customized it just has to receive a 
 different 
 object okay that is instantiated by the 
 web framework 
 pay attention that this might happen 
 inside the same use case so those use 
 cases those two use cases might be the 
 same you might have some logic inside 
 might be part of your business logic 
 that says well in this case i go and 
 fetch things from repo a in this case i 
 go and fetch things from repo b 
 performances for example okay but these 
 repos are something that you get from 
 outside as you see here i'm 
 instantiating them 
 in 
 the 
 web framework not in the use case 
 and the other 
 side of this is that the web framework 
 is just one of the possible front-ends 
 and with front-end now i don't mean 
 react or similar things i mean 
 the way 
 you present your results to the client 
 it might be a command-line 
 interface 
 it might be a web protocol or something 
 else 
 because i just need to call the use case 
 and translate the output of the use case 
 into something that is meaningful for my 
 front end okay http request for a web 
 framework 
 something else for example text for a 
 command line interface 
 okay at this point 
 i want to draw a comparison with an 
 architecture that we 
 or at least many of you probably know 
 which is the django architecture django 
 is a amazing web framework 
 well known in the python community 
 it 
 has a different architecture it's not 
 the clean architecture this doesn't mean 
 it's 
 unclean maybe 
 um well yes it's unclean from 
 given the definition it's unclean 
 what i mean is 
 i don't want to say it's bad okay i'm 
 i'm coming back to this later i just 
 want to draw the comparison for now 
 um well django has models these are 
 similar to entities superficially 
 speaking they just represent part of my 
 business right i have items i have but 
 no books you know films something that 
 i'm 
 marketing 
 i have business logic obviously 
 otherwise why should you use django you 
 have something to market right something 
 to sell 
 business logic in django is usually 
 implemented in views but it can be 
 implemented in functions that are called 
 in views okay so this is similar if you 
 want to what i did before with the clean 
 architecture 
 okay for the first big difference 
 django as an 
 om an object relational mapper 
 which is if you want a gateway it's an 
 interface 
 because 
 if you use um 
 mysql if you use postgres your views 
 don't change right so you are using an 
 interface you are using something that 
 masks the details of the underlying 
 database 
 however the object relational mapper 
 the name says it all it is an interface 
 to relational databases 
 and it's not easy to use 
 django with a non-relational database or 
 with something else okay a web api 
 because of the orm is customized for 
 relational databases and this is 
 different in a clean architecture 
 because the gateways is a more generic 
 definition of interface 
 last two components the database 
 which is an external system 
 which is also tightly connected with 
 models because 
 models in django can be saved and 
 retrieved from the database natively so 
 the models 
 are connected with the database they are 
 aware of the database 
 what is 
 the drawback of this that when you test 
 your 
 django application you need the database 
 it is possible to test it without the 
 database okay but you are 
 sort of fighting against the framework 
 you're doing something that the 
 framework doesn't want you to do so 
 again it might not be bad but it's 
 different okay so there's a big 
 connection between two layers one is the 
 inner layer one is outside and the same 
 happens for the web framework itself as 
 in the part of the framework that 
 deals with http 
 http requests and responses 
 because that is connected with the 
 business logic as i said before you 
 usually implement your business logic in 
 views and views are specific 
 things 
 provided by the web framework they are 
 connected with urls right 
 cool so so far this is the jungle 
 architecture just to show you that there 
 are different approaches to the things 
 and as i said this might be a good 
 approach it's not bad it's just 
 different 
 okay let's assume i convinced you okay 
 in 40 minutes 
 you are like yes the clean architecture 
 is the way to go so i want to go back 
 home and convert everything you know to 
 the clean architecture 
 well um don't do it 
 so oh if you want to do it to do it the 
 right way so i always recommend to 
 you know remember what happens to what 
 happened to netscape when they decided 
 to rewrite the whole thing from scratch 
 they lost everything have you heard of 
 netscape lately no you know well it's 
 resurrected at a certain point 
 but you know uh it's a sad destiny that 
 of netscape and it's for a bad 
 choice 
 so don't do the same choice migrations 
 happen one step at a time 
 so my recommendation if you want to try 
 these concepts 
 is to isolate part of your system some 
 something you know tiny in your system 
 and re-implement it maybe with a clean 
 architecture 
 something that doesn't affect the rest 
 of the of the architecture 
 remember that when it comes to web 
 applications you have load balancers 
 they are your best friends you can 
 always route 
 requests to another system 
 okay and you can go back quickly if it 
 doesn't work 
 final slides is this the definitive 
 architecture so 
 done okay it's the perfect architecture 
 we don't have to do anything else go and 
 implement everything with the 
 clean architecture thank you very much 
 so 
 the answer to this question is 
 in my opinion the answer to any 
 computer science 
 question ever 
 and it is 
 it depends 
 okay 
 it depends on many things it depends on 
 your requirements 
 for example when it comes to the clean 
 architecture versus something else for 
 example the django architecture i tend 
 to show this slide 
 you are the crossroads between these two 
 options 
 lego versus playmobil 
 on the right you have something that 
 works 
 out of the box 
 and it's it's very nice you you can play 
 with it it's amazing you know i don't 
 play with it nowadays but i remember i 
 have fond memories 
 you want a farm you get a farm it's 
 customizable up to a certain point you 
 can move things around okay 
 on the other side on the left 
 you can build whatever you want 
 but you are on your own 
 so it depends 
 what are you constraints what do you 
 want to achieve 
 can you mix and match the two yes you 
 can okay so this is my recommendation 
 always whenever you design a system 
 always stop and think 
 look at the requirements don't go for a 
 solution out of the box 
 it might be the right solution but you 
 have to be you know clear that why it is 
 the right solution 
 really last two slides i wrote a book 
 about these 
 concepts clean architectures in python 
 it's a free book it's available there 
 the example i showed you today comes 
 from the book there i implemented it 
 properly with tdd all the way um 
 a lot of hero checking so the whole book 
 is about that example okay just for 
 achieving a list of objects i 
 implemented it with postgres and mongodb 
 just to show that it's possible to use 
 different databases 
 for the europe items for this week and 
 the next week 
 i teamed up with some friends and i'm 
 offering 
 the book and other books for free it's a 
 bundle worth of 60 dollars so you are 
 free 
 to follow us on twitter and you can 
 check the url on the pub to get the 
 bundle for free 
 with that 
 i'm done 
 i hope it was useful thank you 
 yeah thank you very much leonardo for 
 that very inspiring talk we have a few 
 minutes that 
 are available for questions so if 
 anybody has a question we have a 
 microphone here 
 or just quickly go to that microphone 
 and ask a question i'll be around for 
 the next two hours so feel free to get 
 in touch okay yes uh hello thank you for 
 the really nice presentation and while i 
 try to follow the 
 layered architecture the one thing that 
 i always struggle this with 
 so if you want to really follow this 
 then it seems like you have a lot of 
 duplication so you have to have the 
 models in the core of the business that 
 the your business or your cases are 
 using and then you want to persist also 
 those models into the database or 
 somewhere else you don't need to have 
 some kind of definition of how this 
 happens with some bookkeeping data 
 and potentially the duplicated 
 definition of the original data so it 
 seems there's a lot of duplication so do 
 you have a suggestion how to avoid that 
 or maybe make it less painful to 
 implement the 
 clean architecture 
 i don't think there will be duplication 
 we might we might talk about this later 
 there is definitely a lot of message 
 passing so if that is what you mean by 
 duplication yes the same data is going 
 around a lot which is 
 part of the drawbacks of the clean 
 architecture there are a lot of layers 
 that these might impact performances 
 like you don't have direct access to the 
 database 
 but in terms of duplication i i'm not 
 really sure what you mean so if you want 
 to expand on that for example when in 
 the example at the show for the jungle 
 there is you define the model as and 
 then this that's also the definition of 
 how the table would look like and 
 majority of our m's work the same way 
 so you have a single source of truth 
 that defines basically the layout of the 
 data in the database as well as the 
 layout of the model that you're working 
 with and for the data heavy application 
 that's really convenient and very simple 
 to like work with 
 and define your system so if you don't 
 want to use that 
 then you need to have i definitely see 
 what you mean thank you um now i 
 understand yes it's true that for 
 example the model i use in entities uh 
 correct me if i understood the wrong way 
 is 
 duplicated in the database interface 
 because this is what i'm storing exactly 
 it's so 
 um there is no way to avoid it because 
 this is 
 a feature 
 as in i am splitting the 
 model the entity if you want as in a 
 business entity and the entity as 
 something that is stored in the database 
 i agree this is 
 more work 
 and there is no way to avoid it because 
 it's considered a good thing 
 again it's part of the it depends the 
 requirements you might think that in 
 your business logic this separation is 
 not needed or it's overkill 
 and you're free to go with a different 
 architecture but the idea um 
 if we want the extreme idea is to split 
 these two things because they 
 might exist in the same space but they 
 are not the same thing one thing is the 
 business logic one thing is how i the 
 the business entity if you want and one 
 thing is how i store it 
 thank you 
 thank you very quick 
 final question 
 hi hi leonardo thank you you're welcome 
 i really appreciate your emphasis on 
 beauty and art in terms of software 
 with clean architecture i can see the 
 benefits of say durability 
 utility 
 how it by making a architecture clean do 
 i get beauty out of the box or is there 
 something more elusive uh 
 making something beautiful it might be a 
 bit more elusive um 
 you know beautiful beauty is to be 
 defined 
 um to be honest when i was working on 
 the book and i came up with the example 
 and you know i was looking at the 
 projects where components were how they 
 were interacting between them at a 
 certain point my feeling and this is 
 pretty personal it was like this is this 
 is really beautiful it clicks it works 
 and this is what i uh meant as in 
 beauty for me 
 um it might be subjective okay 
 definitely doesn't shine doesn't come in 
 colors you know but uh the beauty of 
 that system for me is that it's uh again 
 it's tidy i know where things are 
 i'm confident that when i'm touching 
 something and touching just the little 
 universe 
 around that component and not other 
 things 
 this works for me and this is the 
 beauty in that architecture for me 
 thank you very much for the questions 
 and let's have another round of applause 
 for leonardo thank you 
 we're going into lunch break now and the 
 talks will continue from two 
 thanks bye 
 how things are right now there were some 
 really interesting conversations about 
 what could be done to be like more 
 community centered for us to be more 
 community centered how we can help more 
 open source um organizations and more 
 specifically just be more closer to the 
 community 
 so today at europa python i learned 
 about how 
 the new python versions will be 
 optimized and how they will run faster i 
 think that's great news for the future 
 of python 
 the europe python is the gathering of 
 different groups different faults 
 different ideas and but everybody is 
 sticking together with a common language 
 which is python something i really liked 
 learning about which was really cool was 
 these 
 vs code pets which you can have some 
 pets running around in vs code and what 
 i really like about your python is uh 
 now that we're not remote anymore is 
 actually talking to people meeting 
 people and interacting and especially 
 comparing 
 developer setups which we were just 
 doing just now that's really cool 
 during uh our preparations for europe 
 iphone i've learned some animal parts 
 like 
 that zeros have actually vocal 
 vocals and they can speak 
 everything everyone does with python and 
 that's probably one of my favorite 
 things and is the surprises you get from 
 even when you read the abstracts of the 
 talks and you get you think you know 
 what they're going to be talking about 
 and then you go to a talk that you think 
 you will not enjoy that much and it just 
 completely blows your mind 
 and that's that's really really cool 
 this year in europe i learned a lot 
 about the streaming and 
 video cameras and other things knowing 
 people and 
 knowing 
 many different society europa society 
 member and final 
 community members but i think it's very 
 important if you want to be occupied 
 if you want to participate 
 i think my favorite thing about euro 
 python is well the people the people 
 real quiet is just fantastic it's the 
 best people i've ever met 
 for me it's like a 
 nerd camp for all the nerds so it's 
 really nice to meet all the people that 
 i see only once per year at the 
 conference 
 talks are really nice i 
 i learn for example about linters for 
 the import statements which i still have 
 to read about but 
 i learned quite a lot from that 
 this year meeting a lot of friends in 
 person so i've been in europe for three 
 years and this is my first time meeting 
 all of you 
 in real life and that was just amazing 
 was i got five minutes five minutes to 
 prepare for a session share and then 
 after all i got loads of people coming 
 saying thank you and say that they loved 
 it so i think that was a great job 
 and i had fun doing it 
 i think every every day there is 
 something new and funny 
 i think it's just fantastic highly 
 recommend your python and hopefully see 
 you next year 
 umnitsa is the enterprise technology 
 management solution that consolidates 
 data from existing siloed tools to 
 provide a single source of truth for 
 endpoints applications cloud networking 
 and accessories with imnitza you can 
 automate processes from purchase to end 
 of life achieving five key benefits 
 find out how umitza can give you 
 complete control and insight across your 
 technology portfolios book a live demo 
 today at umnitza.com 
 [Music] 
 [Music] 
 [Music] 
 [Music] 
 yes 
 you are actually very serious when you 
 are recording me 
 what did i 
 learn today 
 well i learned that there is a great 
 python community in prague 
 and it would be great to 
 organize maybe the next european there 
 that would be fantastic a great city 
 great people great beer 
 that that would be fantastic 
 today today i learned 
 well how to do an interview i guess 
 the community the people 
 and talking 
 and 
 learning new things 
 i don't know it's fun 
 we had a really interesting discussion 
 about euro python society and you know 
 how 
 things were before how things are right 
 now there were some really interesting 
 conversations about what could be done 
 to be like more community centered uh 
 for us to be more community centered how 
 we can help more open source um 
 organizations and more specifically just 
 be more closer to the community 
 so today at euro python i learned about 
 how 
 the new python versions will be 
 optimized and how they will run faster i 
 think that's great news for the future 
 of python 
 europe python is the gathering of 
 different groups different faults 
 different ideas and but everybody is 
 sticking together with a common language 
 which is python something i really liked 
 learning about which was really cool was 
 these 
 vs code pets which you can have some 
 pets running around in vs code and what 
 i really like about your python is uh 
 now that we're not remote anymore it's 
 actually talking to people meeting 
 people and interacting and especially 
 comparing 
 developer setups which we were just 
 doing just now that's really cool 
 during uh our preparations for your 
 python i've learned some animal parts 
 like uh that giraffes have actually 
 vocal uh 
 vocals and they can speak 
 everything everyone does with python and 
 that's probably one of my favorite 
 things and is the surprises you get from 
 even when you read the abstracts of the 
 talks and you get you think you know 
 what they're going to be talking about 
 and then you go to a talk that you think 
 you will not enjoy that much and it just 
 completely blows your mind and that's 
 that's really really cool this year in 
 europe i thought i learned a lot about 
 the streaming and 
 video cameras and other things knowing 
 people and 
 knowing 
 many different society europa society 
 and 
 community members but i think it's 
 very important if you want to be 
 occupied 
 if you want to participate 
 i think my favorite thing about europa 
 python as well the people the people 
 real quiet are just fantastic it's the 
 best people i've ever met 
 for me it's like a 
 nerd camp for all the nerds so it's 
 really nice to meet all the people that 
 i see only once per year at the 
 conference 
 talks are really nice i 
 i learned for example about linters for 
 the import statements which i still have 
 to read about but 
 i learned quite a lot from that 
 this year meeting a lot of friends in 
 person so i've been in europe for three 
 years and this is my first time meeting 
 all of you 
 in real life and that was just amazing 
 it was i got five minutes five minutes 
 prepare for a session share and then 
 after all i got loads of people coming 
 saying thank you and say that they loved 
 it so i think that was a great job 
 and i had fun doing it 
 i think every every day there is 
 something new and funny 
 i think it's just fantastic i highly 
 recommend your python and hopefully see 
 you next year 
 umnitza is the enterprise technology 
 management solution that consolidates 
 data from existing siloed tools to 
 provide a single source of truth for 
 endpoints applications cloud networking 
 and accessories 
 with imnitza you can automate processes 
 from purchase to end of life achieving 
 five key benefits 
 find out how umnitsa can give you 
 complete control and insight across your 
 technology portfolios book a live demo 
 today at umnitza.com 
 [Music] 
 [Music] 
 [Music] 
 [Music] 
 so 
 take 
 one you are actually very serious when 
 you are recording me 
 what did i learn today 
 well i learned that there is a great 
 python community in prague 
 and it would be great to organize maybe 
 the next euro python there that would be 
 fantastic a great city great people 
 great beer 
 that that would be fantastic 
 today today i learned 
 well how to do an interview i guess 
 the community the people 
 and talking 
 and 
 learning new things 
 i don't know it's fun 
 we had a really interesting discussion 
 about euro python society and you know 
 how 
 things were before how things are right 
 now there were some really interesting 
 conversations about what could be done 
 to be like more community centered for 
 us to be more community centered how we 
 can help more open source um 
 organizations and more specifically just 
 be more closer to the community 
 so today at europa python i learned 
 about how 
 the new python versions will be 
 optimized and how they will run faster i 
 think that's great news for the future 
 of python 
 europe python is 
 the gathering of 
 different groups different faults 
 different ideas and but everybody is 
 sticking together with a common language 
 which is python something i really liked 
 learning about which was really cool was 
 uh these 
 vs code pets which you can have some 
 pets running around in vs code and what 
 i really like about your python is uh 
 now that we're not remote anymore is 
 actually talking to people meeting 
 people and interacting and especially 
 comparing uh developer setups which we 
 were just doing just now that's really 
 cool 
 during uh our preparations for europe 
 iphone i've learned some animal parts 
 like 
 that giraffes have actually vocal 
 vocals and they can speak 
 everything everyone does with python and 
 that's probably one of my favorite 
 things and is the surprises you get from 
 even when you read the abstracts of the 
 talks and you get you think you know 
 what they're going to be talking about 
 and then you go to a talk that you think 
 you will not enjoy that much and it just 
 completely blows your mind 
 and that's that's really really cool 
 this year in europe i learned a lot 
 about the streaming and 
 video cameras and all those things 
 knowing people and 
 knowing 
 many different society europa society 
 member and finance 
 community members but i think it's 
 very important if you want to be 
 occupied 
 if you want to participate 
 i think my favorite thing about euro 
 python is well the people the people 
 real quick is just fantastic it's the 
 best people i've ever met 
 for me it's like a 
 nerd camp for all the nerds so it's 
 really nice to meet all the people that 
 i see only once per year at the 
 conference 
 talks are really nice i 
 i learned for example about linters for 
 the import statements which i still have 
 to read about but 
 i learned quite a lot from that 
 this year meeting a lot of friends in 
 person so i've been in europe for three 
 years and this is my first time meeting 
 all of you 
 in real life and that was just amazing 
 was i got five minutes five minutes 
 prepare for a session share and then 
 after all i got loads of people coming 
 saying thank you and say that they loved 
 it so i think that was a great job 
 and i had fun doing it 
 i think every every day there is 
 something new and funny 
 i think it's just fantastic i highly 
 recommend your python and hopefully see 
 you next year 
 umnitsa is the enterprise technology 
 management solution that consolidates 
 data from existing siloed tools to 
 provide a single source of truth for 
 endpoints applications cloud networking 
 and accessories 
 with imnitza you can automate processes 
 from purchase to end of life achieving 
 five key benefits 
 find out how umitza can give you 
 complete control and insight across your 
 technology portfolios book a live demo 
 today at umnitza.com 
 [Music] 
 so 
 so 
 [Music] 
 [Music] 
 yes 
 you are actually very serious when you 
 are recording me 
 what did i learn today 
 well i learned that there is a great 
 python community in prague 
 and it would be great to 
 organize maybe the next european there 
 that would be fantastic a great city 
 great people great beer 
 that that would be fantastic 
 today today i learned 
 well how to do an interview i guess 
 the community the people 
 and talking 
 and 
 learning new things 
 i don't know it's fun 
 we had a really interesting discussion 
 about euro python society and you know 
 how 
 um things were before how things are 
 right now there were some really 
 interesting conversations about what 
 could be done to be like more community 
 centered for us to be more community 
 centered how we can help more open 
 source um organizations and more 
 specifically just be more closer to the 
 community 
 so today at europa python i learned 
 about how 
 the new python versions will be 
 optimized and how they will run faster i 
 think that's great news for the future 
 of python 
 the euro python is the gathering of 
 different groups different faults 
 different ideas and but everybody is 
 sticking together with a common language 
 which is python something i really liked 
 learning about which was really cool was 
 these 
 vs code pets which you can have some 
 pets running around in vs code and what 
 i really like about europe python is uh 
 now that we're not remote anymore is 
 actually talking to people meeting 
 people and interacting and especially 
 comparing uh 
 developer setups which we were just 
 doing just now that's really cool 
 during uh our preparations for european 
 i've learned some animal parts like 
 giraffes have actually vocal 
 vocals and they can speak 
 everything everyone does with python and 
 that's probably one of my favorite 
 things and is the surprises you get from 
 even when you read the abstracts of the 
 talks and you get you think you know 
 what they're going to be talking about 
 and then you go to a talk that you think 
 you will not enjoy that much and it just 
 completely blows your mind 
 and that's that's really really cool 
 this year in europe i learned a lot 
 about the streaming and 
 video cameras and other things knowing 
 people and 
 knowing 
 many different society europa society 
 members 
 community members but i think it's 
 very important if you want to be 
 occupied 
 if you want to participate 
 i think my favorite thing about euro 
 python is well the people the people 
 around python is just fantastic it's the 
 best people i've ever met 
 for me it's like a 
 nerd camp for all the nerds so it's 
 really nice to meet all the people that 
 i see only once per year at the 
 conference 
 talks are really nice i 
 i learned for example about linters for 
 the import statements which i still have 
 to read about but 
 i learned quite a lot from that 
 this year meeting a lot of friends in 
 person so i've been in europe for three 
 years and this is my first time meeting 
 all of you 
 in real life and that was just amazing 
 it was i got five minutes five minutes 
 prepare for a session share and then 
 after all i got loads of people coming 
 saying thank you and they say that they 
 loved it so i think that was a great job 
 and i had fun doing it 
 i think every every day there is 
 something new and funny 
 i think it's just fantastic i highly 
 recommend your python and hopefully see 
 you next year 
 umnitza is the enterprise technology 
 management solution that consolidates 
 data from existing siloed tools to 
 provide a single source of truth for 
 endpoints applications cloud networking 
 and accessories 
 with imnitza you can automate processes 
 from purchase to end of life achieving 
 five key benefits 
 find out how umitza can give you 
 complete control and insight across your 
 technology portfolios book a live demo 
 today at umnitza.com 
 [Music] 
 [Music] 
 [Music] 
 [Music] 
 [Music] 
 yes 
 you are actually very serious when you 
 are recording me 
 what did i learn today 
 well i learned that there is a great 
 python community in prague 
 and it would be great to organize maybe 
 the next europe python there that would 
 be fantastic a great city great people 
 great beer 
 that that would be fantastic 
 today today i learned 
 well how to do an interview i guess 
 the community the people 
 and talking 
 and 
 learning new things 
 i don't know it's fun 
 we had a really interesting discussion 
 about europa's society and you know how 
 things were before how things are right 
 now there were some really interesting 
 conversations about what could be done 
 to be like more community centered uh 
 for us to be more community centered how 
 we can help more open source um 
 organizations and more specifically just 
 be more closer to the community so today 
 at euro python i learned about how 
 the new python versions will be 
 optimized and how they will run faster i 
 think that's great news for the future 
 of python 
 the european is the gathering of 
 different groups different faults 
 different ideas and but everybody is 
 sticking together with a common language 
 which is python something i really liked 
 learning about which was really cool was 
 these 
 vs code pets which you can have some 
 pets running around in vs code and what 
 i really like about your python is uh 
 now that we're not remote anymore it's 
 actually talking to people meeting 
 people and interacting and especially 
 comparing 
 developer setups which we were just 
 doing just now that's really 
 cool during uh our preparations for 
 european i've learned some animal parts 
 like uh that giraffes have actually 
 vocal 
 vocals and they can speak 
 everything everyone does with python and 
 that's probably one of my favorite 
 things and is the surprises you get from 
 even when you read the abstracts of the 
 talks and you get you think you know 
 what they're going to be talking about 
 and then you go to a talk that you think 
 you will not enjoy that much and it just 
 completely blows your mind 
 and that's that's really really cool 
 this year in europe i learned a lot 
 about the streaming and 
 video cameras and other things knowing 
 people and knowing 
 many different society european society 
 and python 
 community members but i think it's 
 very important if you want to be 
 occupied 
 if you want to participate 
 i think my favorite thing about euro 
 python is well the people the people are 
 real fighters are just fantastic it's 
 the best people i've ever met 
 for me it's like a 
 nerd cam for 
 all the nerds so it's really nice to 
 meet all the people that i see only once 
 per year at the conference 
 talks are really nice i 
 i learned for example about linters for 
 the import statements which i still have 
 to read about but 
 i learned quite a lot from that 
 this year meeting a lot of friends in 
 person so i've been in europe for three 
 years and this is my first time meeting 
 all of you 
 in real life and that was just amazing 
 i got five minutes five minutes to 
 prepare for a session share and then 
 after all i got loads of people coming 
 saying thank you and say that they loved 
 it so i think that was a great job 
 and i had fun doing it 
 i think every every day there is 
 something new and funny 
 i think it's just fantastic i highly 
 recommend your python and hopefully see 
 you next year 
 umnitza is the enterprise technology 
 management solution that consolidates 
 data from existing siloed tools to 
 provide a single source of truth for 
 endpoints applications cloud networking 
 and accessories 
 with imnitza you can automate processes 
 from purchase to end of life achieving 
 five key benefits 
 find out how umnitza can give you 
 complete control and insight across your 
 technology portfolios book a live demo 
 today at umnitza.com 
 [Music] 
 so 
 [Music] 
 [Music] 
 [Music] 
 take one 
 you are actually very serious when you 
 are recording me 
 what did i learn today 
 well i learned that there is a great 
 python community in prague 
 and it would be great to organize maybe 
 the next euro python there that would be 
 fantastic a great city great people 
 great beer 
 that that would be fantastic 
 today today i learned 
 well how to do an interview i guess 
 the community the people 
 and talking 
 and 
 learning new things 
 i don't know it's fun 
 we had a really interesting discussion 
 about euro python society and you know 
 how 
 um things were before how things are 
 right now there were some really 
 interesting conversations about what 
 could be done to be like more community 
 centered uh for us to be more community 
 centered how we can help more open 
 source um organizations and more 
 specifically just be more closer to the 
 community 
 so today at euro python i learned about 
 how 
 the new python versions will be 
 optimized and how they will run faster i 
 think that's great news for the future 
 of python 
 the european is the gathering of 
 different groups different faults 
 different ideas and but everybody is 
 sticking together with a common language 
 which is patent something i really liked 
 learning about which was really cool was 
 these 
 vs code pets which you can have some 
 pets running around in vs code and what 
 i really like about europe python is uh 
 now that we're not remote anymore is 
 actually talking to people meeting 
 people and interacting and especially 
 comparing 
 developer setups which we were just 
 doing just now that's really cool 
 during uh our preparations for europe 
 iphone i've learned some animal parts 
 like uh that giraffes have actually 
 vocal 
 vocals and they can speak 
 everything everyone does with python and 
 that's probably one of my favorite 
 things and is the surprises you get from 
 even when you read the abstracts of the 
 talks and you get you think you know 
 what they're going to be talking about 
 and then you go to a talk that you think 
 you will not enjoy that much and it just 
 completely blows your mind 
 and that's that's really really cool 
 this year in europe i learned a lot 
 about the streaming and 
 video cameras and other things knowing 
 people and uh knowing 
 many different societal society members 
 and finance 
 community members but i think it's 
 very important if you want to be 
 occupied if you want to participate 
 i think my favorite thing about euro 
 python is well the people the people 
 real quite are just fantastic it's the 
 best people i've ever met 
 for me it's like a 
 nerd camp for 
 all the nerds so it's really nice to 
 meet all the people that i see only once 
 per year at the conference 
 talks are really nice i 
 i learned for example about linters for 
 the import statements which i still have 
 to read about but 
 i learned quite a lot from that 
 this year meeting a lot of friends in 
 person so i've been in europe for three 
 years and this is my first time meeting 
 all of you 
 in real life and that was just amazing 
 was i got five minutes five minutes to 
 prepare for a session share and then 
 after all i got loads of people coming 
 saying thank you and they say that they 
 loved it so i think that was a great job 
 and i had fun doing it 
 i think every every day there is 
 something new and funny 
 i think it's just fantastic i highly 
 recommend europe python and hopefully 
 see you next year 
 umnitza is the enterprise technology 
 management solution that consolidates 
 data from existing siloed tools to 
 provide a single source of truth for 
 endpoints applications cloud networking 
 and accessories 
 with imnitza you can automate processes 
 from purchase to end of life achieving 
 five key benefits 
 find out how umnitza can give you 
 complete control and insight across your 
 technology portfolios book a live demo 
 today at umnitza.com 
 [Music] 
 [Music] 
 [Music] 
 [Music] 
 yes 
 you are actually very serious when you 
 are recording me 
 what did i learn today 
 well i learned that there is a great 
 python community in prague 
 and it would be great to organize maybe 
 the next euro python there that would be 
 fantastic a great city great people 
 great beer 
 that that would be fantastic 
 today today i learned 
 well how to do an interview i guess 
 the community the people 
 and talking 
 and 
 learning new things 
 i don't know it's fun 
 we had a really interesting discussion 
 about euro python society and you know 
 how 
 things were before how things are right 
 now there were some really interesting 
 conversations about what could be done 
 to be like more community centered for 
 us to be more community centered how we 
 can help more open source um 
 organizations and more specifically just 
 be more closer to the community 
 so today at your python i learned about 
 how 
 the new python versions will be 
 optimized and how they will run faster i 
 think that's great news for the future 
 of python 
 the european is the gathering of 
 different groups different faults 
 different ideas and but everybody is 
 sticking together with a common language 
 which is python something i really liked 
 learning about which was really cool was 
 these 
 vs code pets which you can have some 
 pets running around in vs code and what 
 i really like about your python is uh 
 now that we're not remote anymore is 
 actually talking to people meeting 
 people and interacting and especially 
 comparing uh 
 developer setups which we were just 
 doing just now that's really cool 
 during uh our preparations for europe 
 iphone i've learned some animal parts 
 like 
 that giraffes have actually vocal 
 vocals and they can speak 
 everything everyone does with python and 
 that's probably one of my favorite 
 things and is the surprises you get from 
 even when you read the abstracts of the 
 talks and you get you think you know 
 what they're going to be talking about 
 and then you go to a talk that you think 
 you will not enjoy that much and it just 
 completely blows your mind 
 and that's that's really really cool 
 this year in europe i learned a lot 
 about the streaming and 
 video cameras and other things knowing 
 people and knowing 
 many different society europa society 
 and python 
 community members but i think it's 
 very important if you want to be 
 occupied 
 if you want to participate 
 i think my favorite thing about euro 
 python is well the people the people 
 real quicker are just fantastic it's the 
 best people i've ever met 
 for me it's like a 
 nerd camp for 
 all the nerds so it's really nice to 
 meet all the people that i see only once 
 per year at the conference 
 talks are really nice i 
 learned for example about linters for 
 the import statements which i still have 
 to read about but 
 i learned quite a lot from that 
 this year meeting a lot of friends in 
 person so i've been in europe for three 
 years and this is my first time meeting 
 all of you in real life and that was 
 just amazing 
 i got five minutes five minutes to 
 prepare for a session share and then 
 after all i got loads of people coming 
 saying thank you and they say that they 
 loved it so i think that was a great job 
 and i had fun doing it 
 i think every every day there is 
 something new and funny 
 i think it's just fantastic i highly 
 recommend europe python and hopefully 
 see you next year 
 um nitza is the enterprise technology 
 management solution that consolidates 
 data from existing siloed tools to 
 provide a single source of truth for 
 endpoints applications cloud networking 
 and accessories 
 with imnitza you can automate processes 
 from purchase to end of life achieving 
 five key benefits 
 find out how umnitza can give you 
 complete control and insight across your 
 technology portfolios book a live demo 
 today at umnitza.com 
 [Music] 
 so 
 [Music] 
 [Music] 
 [Music] 
 yes 
 you are actually very serious when you 
 are recording me 
 what did i learn today well i learned 
 that there is a great python community 
 in prague 
 and it would be great to organize maybe 
 the next europe python there that would 
 be fantastic a great city great people 
 great beer 
 that that would be fantastic 
 today today i learned 
 well how to do an interview i guess the 
 community the people 
 and talking 
 and 
 learning new things 
 i don't know it's fun 
 we had a really interesting discussion 
 about euro python society and you know 
 how 
 things were before how things are right 
 now there were some really interesting 
 conversations about what could be done 
 to be like more community centered for 
 us to be more community centered how we 
 can help more open source um 
 organizations and more specifically just 
 be more closer to the community 
 so today at euro python i learned about 
 how 
 the new python versions will be 
 optimized and how they will run faster i 
 think that's great news for the future 
 of python 
 the european is the gathering of 
 different groups different faults 
 different ideas and but everybody is 
 sticking together with a common language 
 which is python something i really liked 
 learning about which was really cool was 
 these 
 vs code pets which you can have some 
 pets running around in vs code and what 
 i really like about europe python is uh 
 now that we're not remote anymore is 
 actually talking to people meeting 
 people and interacting and especially 
 comparing 
 developer setups which we were just 
 doing just now that's really cool during 
 our preparations for your python i've 
 learned some animal parts like uh that 
 giraffes have actually vocal 
 vocals and they can speak 
 everything everyone does with python and 
 that's probably one of my favorite 
 things and is the surprises you get from 
 even when you read the abstracts of the 
 talks and you get you think you know 
 what they're going to be talking about 
 and then you go to a talk that you think 
 you will not enjoy that much and it just 
 completely blows your mind 
 and that's that's really really cool 
 this year in europe i learned a lot 
 about the streaming and 
 video cameras and all the things knowing 
 people and knowing 
 many different society europa society 
 members and 
 community members but i think it's 
 very important if you want to be 
 occupied 
 if you want to participate 
 i think my favorite thing about euro 
 python is well the people the people 
 real quiet are just fantastic it's the 
 best people i've ever met 
 for me it's like a 
 nerd camp for 
 all the nerds so it's really nice to 
 meet all the people that i see only once 
 per year at the conference 
 talks are really nice i 
 i learned for example about linters for 
 the import statements which i still have 
 to read about but 
 i learned quite a lot from that 
 this year meeting a lot of friends in 
 person so i've been in europe for three 
 years and this is my first time meeting 
 all of you 
 in real life and that was just amazing 
 i got five minutes five minutes to 
 prepare for a session share 
 and then after all i got loads of people 
 coming saying thank you and they say 
 that they loved it so i think that was a 
 great job 
 and i had fun doing it 
 i think every every day there is 
 something new and funny i think it's 
 just fantastic i highly recommend europe 
 python and hopefully see you next year 
 umnitza is the enterprise technology 
 management solution that consolidates 
 data from existing siloed tools to 
 provide a single source of truth for 
 endpoints applications cloud networking 
 and accessories 
 with imnitza you can automate processes 
 from purchase to end of life achieving 
 five key benefits 
 find out how umitza can give you 
 complete control and insight across your 
 technology portfolios book a live demo 
 today at umnitza.com 
 [Music] 
 [Music] 
 [Music] 
 [Music] 
 take one 
 you are actually very serious when you 
 are recording me 
 what did i learn today well i learned 
 that there is a great python community 
 in prague 
 and it would be great to organize maybe 
 the next euro python there that would be 
 fantastic a great city great people 
 great beer 
 that that would be fantastic 
 today today i learned 
 well how to do an interview i guess 
 the community the people 
 and talking 
 and 
 learning new things 
 i don't know it's fun 
 we had a really interesting discussion 
 about euro python society and you know 
 how 
 um things were before how things are 
 right now there were some really 
 interesting conversations about what 
 could be done to be like more community 
 centered for us to be more community 
 centered how we can help more open 
 source um organizations and more 
 specifically just be more closer to the 
 community 
 so today at euro python i learned about 
 how 
 the new python versions will be 
 optimized and how they will run faster i 
 think that's great news for the future 
 of python 
 the european is the gathering of 
 different groups different faults 
 different ideas and but everybody is 
 sticking together with a common language 
 which is python something i really liked 
 learning about which was really cool was 
 these 
 vs code pets which you can have some 
 pets running around in vs code and what 
 i really like about your python is uh 
 now that we're not remote anymore is 
 actually talking to people meeting 
 people and interacting and especially 
 comparing 
 developer setups which we were just 
 doing just now that's really cool 
 during 
 our preparations for europe iphone i've 
 learned some animal parts like 
 that giraffes have actually vocal 
 vocals and they can speak 
 everything everyone does with python and 
 that's probably one of my favorite 
 things and is the surprises you get from 
 even when you read the abstracts of the 
 talks and you get you think you know 
 what they're going to be talking about 
 and then you go to a talk that you think 
 you will not enjoy that much and it just 
 completely blows your mind 
 and that's that's really really cool 
 this year in europe i learned a lot 
 about the streaming and 
 video cameras and all those things 
 knowing people and 
 knowing 
 many 
 different society europa society and 
 typhoon 
 community members but i think it's 
 very important if you want to be 
 occupied 
 if you want to participate 
 i think my favorite thing about euro 
 python is well the people the people 
 real quiet is just fantastic it's the 
 best people i've ever met 
 for me it's like a 
 nerd camp for 
 all the nerds so it's really nice to 
 meet all the people that i see only once 
 per year at the conference 
 talks are really nice i 
 i learned for example about linters for 
 the import statements which i still have 
 to read about but 
 i learned quite a lot from that 
 this year meeting a lot of friends in 
 person so i've been in europe for three 
 years and this is my first time meeting 
 all of you 
 in real life and that was just amazing 
 was i got five minutes five minutes 
 prepare for a session share and then 
 after all i got loads of people coming 
 saying thank you and to say that they 
 loved it so i think that was a great job 
 and i had fun doing it 
 i think every every day there is 
 something new and funny 
 i think it's just fantastic i highly 
 recommend europe python and hopefully 
 see you next year 
 umnitza is the enterprise technology 
 management solution that consolidates 
 data from existing siloed tools to 
 provide a single source of truth for 
 endpoints applications cloud networking 
 and accessories 
 with imnitza you can automate processes 
 from purchase to end of life achieving 
 five key benefits 
 find out how omnitsa can give you 
 complete control and insight across your 
 technology portfolios book a live demo 
 today at umnitza.com 
 [Music] 
 [Music] 
 [Music] 
 [Music] 
 you are actually very serious when you 
 are recording me 
 what did i learn today well i learned 
 that there is a great python community 
 in prague and it would be great to 
 organize maybe the next europe python 
 there that would be fantastic a great 
 city great people great beer 
 that that would be fantastic 
 today today i learned 
 well how to do an interview i guess 
 the community the people 
 and talking 
 and learning new things 
 i don't know it's fun 
 we had a really interesting discussion 
 about euro python society and you know 
 how 
 things were before how things are right 
 now there were some really interesting 
 conversations about what could be done 
 to be like more community centered for 
 us to be more community centered how we 
 can help more open source um 
 organizations and more specifically just 
 be more closer to the community 
 so today at your python i learned about 
 how the new python versions will be 
 optimized and how they will run faster i 
 think that's great news for the future 
 of python 
 the european is the gathering of 
 different groups different faults 
 different ideas and but everybody is 
 sticking together with a common language 
 which is python something i really liked 
 learning about which was really cool was 
 these 
 vs code pets which you can have some 
 pets running around in vs code and what 
 i really like about your python is uh 
 now that we're not remote anymore it's 
 actually talking to people meeting 
 people and interacting and especially 
 comparing 
 developer setups which we were just 
 doing just now that's really cool 
 during our preparations for europe 
 iphone i've learned some animal parts 
 like 
 giraffes have actually vocal 
 vocals and they can speak 
 everything everyone does with python and 
 that's probably one of my favorite 
 things and is the surprises you get from 
 even when you read the abstracts of the 
 talks and you get you think you know 
 what they're going to be talking about 
 and then you go to a talk that you think 
 you will not enjoy that much and it just 
 completely blows your mind 
 and that's that's really really cool 
 this year in europe i thought i learned 
 a lot about the streaming and 
 video cameras and other things knowing 
 people and 
 knowing 
 many different societies europa society 
 member and final 
 community members but i think it's 
 very important if you want to be 
 occupied 
 if you want to participate 
 i think my favorite thing about euro 
 python is well the people the people 
 real quick is just fantastic it's the 
 best people i've ever met 
 for me it's like a nerd camp for 
 all the nerds so it's really nice to 
 meet all the people that i see only once 
 per year at the conference 
 talks are really nice i i learned for 
 example about linters for the import 
 statements which i still have to read 
 about but 
 i learned quite a lot from that 
 this year meeting a lot of friends in 
 person so i've been in europe for three 
 years and this is my first time meeting 
 all of you in real life and that was 
 just amazing was i got five minutes five 
 minutes prepare for a session share and 
 then after all i got loads of people 
 coming saying thank you and they say 
 that they loved it so i think that was a 
 great job 
 and i had fun doing it 
 i think every every day there is 
 something new and funny 
 i think it's just fantastic highly 
 recommend euro python and hopefully see 
 you next year 
 umnitza is the enterprise technology 
 management solution that consolidates 
 data from existing siloed tools to 
 provide a single source of truth for 
 endpoints applications cloud networking 
 and accessories 
 with imnitza you can automate processes 
 from purchase to end of life achieving 
 five key benefits 
 find out how umitza can give you 
 complete control and insight across your 
 technology portfolios book a live demo 
 today at umnitza.com 
 [Music] 
 [Music] 
 [Music] 
 do 
 [Music] 
 you are actually very serious when you 
 are recording me 
 what did i learn today 
 well i learned that there is a great 
 python community in prague 
 and it would be great to organize maybe 
 the next europe python there that would 
 be fantastic a great city great people 
 great beer that that would be fantastic 
 today today i learned 
 well how to do an interview i guess 
 the community the people 
 and talking 
 and 
 learning new things 
 i don't know it's fun 
 we had a really interesting discussion 
 about euro python society and you know 
 how 
 um things were before how things are 
 right now there were some really 
 interesting conversations about what 
 could be done to be like more community 
 centered uh for us to be more community 
 centered how we can help more open 
 source um organizations and more 
 specifically just be more closer to the 
 community 
 so today at your python i learned about 
 how 
 the new python versions will be 
 optimized and how they will run faster i 
 think that's great news for the future 
 of python 
 the european is the gathering of 
 different groups different faults 
 different ideas and but everybody is 
 sticking together with a common language 
 which is python something i really liked 
 learning about which was really cool was 
 these 
 vs code pets which you can have some 
 pets running around in vs code and what 
 i really like about europe python is uh 
 now that we're not remote anymore is 
 actually talking to people meeting 
 people and interacting and especially 
 comparing uh 
 developer setups which we were just 
 doing just now that's really cool 
 during uh our preparations for europe 
 iphone i've learned some animal parts 
 like uh 
 that giraffes have actually vocal 
 vocals and they can speak 
 everything everyone does with python and 
 that's probably one of my favorite 
 things and is the surprises you get from 
 even when you read the abstracts of the 
 talks and you get you think you know 
 what they're going to be talking about 
 and then you go to a talk that you think 
 you will not enjoy that much and it just 
 completely blows your mind 
 and that's that's really really cool 
 this year in europe i learned a lot 
 about the streaming and 
 video cameras and other things knowing 
 people and 
 knowing 
 many 
 different societal societies member and 
 finance 
 community members but i think it's 
 very important if you want to be 
 occupied 
 if you want to participate 
 joining 
 i think my favorite thing about euro 
 python is well the people the people 
 real quiet is just fantastic it's the 
 best people i've ever met 
 for me it's like a 
 nerd cam for 
 all the nerds so it's really nice to 
 meet all the people that i see only once 
 per year at the conference 
 talks are really nice i 
 i learned for example about linters for 
 the import statements which i still have 
 to read about but 
 i learned quite a lot from that talk 
 this year meeting a lot of friends in 
 person so i've been in europe for three 
 years and this is my first time meeting 
 all of you 
 in real life and that was just amazing 
 i got five minutes five minutes prepare 
 for a session share and then after all i 
 got loads of people coming saying thank 
 you and they say that they loved it so i 
 think that was a great job 
 and i had fun doing it 
 i think every every day there is 
 something new and funny 
 i think it's just fantastic i highly 
 recommend europe python and hopefully 
 see you next year 
 umnitza is the enterprise technology 
 management solution that consolidates 
 data from existing siloed tools to 
 provide a single source of truth for 
 endpoints applications cloud networking 
 and accessories 
 with imnitza you can automate processes 
 from purchase to end of life achieving 
 five key benefits find out how umitza 
 can give you complete control and 
 insight across your technology 
 portfolios book a live demo today at 
 umnitza.com 
 [Music] 
 [Music] 
 [Music] 
 [Music] 
 take one 
 you are actually very serious when you 
 are recording me 
 what did i learn today 
 well i learned that there is a great 
 python community in prague and it would 
 be great to organize maybe the next 
 europe python there that would be 
 fantastic a great city great people 
 great beer that 
 all right good afternoon and welcome to 
 our next talk 2 p.m talk packaging 
 security of nyx with ryan 
 thank you very much i'm very happy to 
 give this talk and discuss with you 
 about 
 uh two things i really enjoy and love 
 nix and python 
 and also security 
 so 
 oh 
 yeah 
 just need to bring in on 
 so just to start a bit of context we're 
 going to define what we are going to 
 use for this talk 
 and 
 just so you know the talk is available 
 at my github repository and everything 
 is there demo examples and these various 
 talk and its sources 
 so 
 in python and package is usually a tree 
 of files containing a special file the 
 name of the root folder is the name of 
 the package and you can import it under 
 the right conditions so you can temper 
 with the import paths or something very 
 well a lot of super interesting talk 
 about 
 different features which 
 modify the way import machinery works in 
 python and 
 well 
 in some system in some contexts we 
 actually do use 
 those for legitimate reason for example 
 in nix 
 we use pth files and sites to uh make it 
 easy to import any package uh in an 
 isolated way 
 like virtual off enables you to do so 
 uh so everything we installed from any 
 pipe pipe i like server 
 is a package and every package manager 
 you've used is also something that 
 provides for package and use these 
 indexes 
 so 
 now thinking about people like us users 
 we install packages 
 manually we type in our terminal or by 
 using 
 graphical interfaces 
 to install some packages that could be 
 numpy that could be scipy that could be 
 whatever you need and 
 we do install those on a computer uh 
 we're running a certain operating system 
 and on this computer there are things 
 those things are some source code as 
 such keys personal file professional 
 file secrets 
 and 
 to us they they might be something that 
 we don't care about that may be 
 something that we forgot that we have 
 um 
 but to other people that might become 
 they might become valuable targets and 
 that's really important to think about 
 this because the computer that we carry 
 on contains very important data and some 
 people 
 try to enforce the fact that you have to 
 encrypt your computer to prevent for 
 data loss and catastrophic failures 
 and we can also 
 extend these kind of ideas to servers 
 and deployments because they're kind of 
 the same except you replace the human 
 interaction by automation 
 so some valuable targets reach a lot 
 install time when you install a package 
 are ssh keys ssr servers browser 
 profiles 
 and whatever you name it 
 because 
 all of those are available in your user 
 so sometimes you can try to do things to 
 isolate where you're installing your 
 packages so you use docker you do 
 something like that 
 but not everyone does that not every 
 package manager provides for package 
 package isolation 
 so 
 [Music] 
 yeah 
 just a quick reminder how to publish a 
 package to pi pa uh we write down 
 instructions uh to use our package so 
 meta some metadata and we perform some 
 operations uh i think it's really 
 interesting that uh 
 the most easiest way to describe how to 
 publish a package is that 
 at install time we perform some 
 operations 
 because uh iso historically in order to 
 install package you have to read down a 
 setup.pi which is a fully um 
 complete python program which exposes an 
 install command and you can run 
 everything in this installed command 
 and this code gets shipped to pipe pi 
 and is run arbitrary when you run when 
 you install your package 
 so maybe we don't really care about 
 the fact that we can run arbitrary code 
 at install time but unfortunately we 
 have some example of 
 annoying things and really bad things 
 done with the with with these pictures 
 so for example 
 date util is very known a very known 
 package to deal with dates 
 and uh some people 
 some of you might remember the python 2 
 to python 3 transition which was quite 
 painful and some packages we which were 
 not compatible with python 3 started to 
 create 
 new packages compatible under the name 
 python3 dash package and of course 
 someone published the python free dash 
 date util package 
 but 
 that was not uh innocent package 
 so 
 on 2019 
 someone published a malicious package 
 behind this 
 which was which were depending on the 
 jellyfish package uh and playing her 
 with a homoglyph attack uh playing on 
 the i or l 
 uh 
 confusion 
 and 
 this 
 payload try to attack a very specific 
 person 
 because if you 
 unpack everything gets the code extra 
 which is on the issue by the way 
 you can see that it was trying to test 
 if someone had a very specific file 
 which had not a very random name or one 
 was not on every computer 
 so um we can infer that it was a quite 
 sophisticated attack towards one 
 developer 
 so it's quite frightening and makes you 
 wonder 
 how 
 frequent this attack are in fact 
 and uh some other talks talked about 
 that 
 uh 
 there are a lot of malicious packages 
 which uses typo squaring or even like uh 
 i think honest uh type of squatting 
 um 
 some packages were definitely downloaded 
 too much 
 for example dpp client 
 and recently pi pi re rolled out 
 mandatory two-factor authentication for 
 critical packages 
 and you might have noticed this last 
 week there there was some drama about it 
 because 
 pipei did a great job i think giving out 
 a free two-factor authentication to 
 critical package maintainers uh but some 
 maintainers didn't want to enable 
 two-factor authentication so they uh are 
 good but it's it's something 
 it's like 
 if you're a maintainer of some package 
 for free software uh are you really 
 concerned about the security of your 
 users and i think that's a philosophical 
 question so let's put it aside 
 um 
 the question we ask is why 
 arbitrary code execution is needed 
 most of the package we install are 
 mostly declare declaring their 
 dependencies 
 so 
 we say that numpy depends our some 
 numerical library and so on and so forth 
 and pip or any package manager use this 
 to perform some topological sort and 
 version resolution 
 but 
 our 
 our 
 our formats our the way how we describe 
 our package does not take into account 
 uh the problem that 
 comes with system level dependencies so 
 when you install something like 
 beautiful soup which comes with a html 
 parser you need some xml parser and you 
 want a fast xml parser so lxml is a one 
 good candidate and it requires to 
 install 
 c libraries so you have to coordinate 
 with system package manager you have 
 also the problem when you're using 
 numerical libraries such as cipher numpy 
 you can change the inner 
 acceleration 
 to choose an acceleration which works 
 better on your hardware so for intel mkl 
 you will get better acceleration 
 intel based processors uh open blast is 
 the generic implementation which works 
 quite fine for every processor 
 which was rude by the research and you 
 have the same for amd and so on and so 
 forth same for tensorflow and cuda 
 because you have some specific 
 specifics about gpus 
 and uh you have neon purely python 
 packages also uh which are 
 written in another language such as rest 
 must be compiled and exposed to your 
 python package 
 and 
 when you pip install social package and 
 you don't have any will for it uh you 
 need to build it and python is not going 
 to install a russ compiler for you so 
 the author is going to install the rest 
 compiler for you 
 and you have many over example of why 
 this is needed so we can argue that 
 maybe that's the wrong model and should 
 do something else extra but that's the 
 reality so you have to work with that 
 with this 
 and this is possible because there is no 
 real alternative to the problem there 
 was some interesting talk about the 
 update framework and and many other 
 attempts to to try to solve this problem 
 but not all can account for everything i 
 just mentioned and this is still very 
 work in progress 
 so 
 one of the problem i think is is hard 
 here is that not only you have to 
 support like linux distribution we which 
 all have a way to do things uh some are 
 source based you take arc linux gain two 
 and so on forth some are binary based 
 debian ubuntu extra 
 and they don't necessarily agree on 
 who is responsible to bring you to the 
 final mile of dependency 
 and also what something i i don't say is 
 about windows mac os and so on and so 
 forth 
 and finally software editors have to 
 make assumptions 
 there are no easy way to discover some 
 standard standards sometimes so for 
 example when you do a say library 
 or native library you can use something 
 called pkg-config to discover library 
 paths and pass parameters to your 
 compiler and that requires you to 
 provide a pc file and sometimes upstream 
 developers forgot about them and 
 downstream 
 downstream maintainers have to add them 
 manually but they don't necessarily get 
 them upstream so 
 it creates a lot of fragmentation and 
 difficulties to to handle everything 
 so downstream motors have to do 
 workarounds python developers python 
 package packager uh have to do something 
 in their setup.pi so that the experience 
 is streamlined and very user-friendly 
 and 
 as a result 
 you have a great success of using 
 something like docker and friends 
 because they provide a streamlined 
 experience in a clean state 
 which would be here a container 
 so we could decide that yeah that's the 
 state of thing and we might need to 
 restart 
 packaging someday and and do it fine do 
 it good and get some 10 years milestone 
 plan to get us there 
 but this talk is about nyx 
 so let's do a next crash course 
 what is next so the idea behind nyx is a 
 functional nix language 
 and it's a general package manager which 
 is able to work with other package 
 managers the provoking idea of nyx is we 
 break the file system your archistandar 
 so you don't get any slash user extra 
 you only get your state files so 
 home and and so on so forth everything 
 is a sim link of something in the next 
 door so 
 that makes it really easy to reason 
 about what you have in your system 
 and everything is recorded and you have 
 a cryptographic ash we'll come back to 
 the cryptography cache later 
 packages are not really packages in nyx 
 we don't have any concept of packages we 
 have concept of derivation which is a 
 more general concept and 
 we express something in the next 
 language and produce 
 outputs so that can be a package that 
 can be a system that you need file that 
 can be a bash script that can be a 
 python script 
 everything goes 
 so here's an example of 
 file system hierarchy standard 
 you can find those as being srv ussr var 
 that you often find on your system 
 but on nx those either don't exist or 
 are symlink of a special next door path 
 so just to get some 
 example uh of what is next 
 uh here's the next language now 
 so this is an expression to build a 
 python package so you have some import 
 of the package the list of packages we 
 have so this is a function signature 
 we have a function call 
 we call the build python package 
 function 
 we give a name we give version we give 
 the source 
 notice that we give the ash that's 
 something that prevents um in next 
 network process is disabled except for 
 derivation which have a hash so that we 
 can already know the results in advance 
 so 
 if by pip i tried to change 
 the contents uh the result would be 
 rejected because the ash would change so 
 this protects us a bit but not a lot 
 um and we have some metadata about 
 the package 
 so the the next path so we said that we 
 have the next path here is the 
 cryptographic hash 
 a nice property of next is that this 
 cryptography ash uniquely identify your 
 your package 
 either things are input address that 
 means that your package is a function of 
 the inputs if you change numpy 
 and you depend on them by your package 
 is going to change 
 or either content addressed that means 
 that even if numpy change changes but 
 your result won't change because it's a 
 minor ipi 
 bomb or something 
 the hash won't change so that's really 
 interesting because you never build 
 software twice except for very good 
 reasons and 
 that make it trivial to cache 
 derivations and provide them to everyone 
 and then you get a name a nice name 
 and get now now you get something that 
 you you all use too which is the ba the 
 bin folder the lib folder etc 
 so here's some glossary basic glossary 
 of the next terms i'm going to go fast 
 on them 
 the next store is the file system where 
 everything is recorded including the 
 derivations the store path is 
 either output produced by a derivation 
 file or the derivation file itself so 
 you can send derivation to someone else 
 and it can build it for you 
 and you can get the outputs 
 um derivation is the recip so when you 
 say i want to build tools like we've 
 seen earlier you say that this is a 
 python package and all python packages 
 have a way to be built which is running 
 the setup.pi 
 and 
 and then we just give some parameters 
 that we need so the source the name the 
 version uh some metadata some metadata 
 uh and what is interesting about it is 
 that even a full nexus linux system is 
 just one big derivation which is your 
 calendar your initially um 
 your bootscript extra extra and you can 
 have a tree which i will showcase 
 later of your wall system uh and then 
 the mathematical concept of closure 
 which is that's when you have a binary 
 relation such as software x dependent 
 software y 
 uh often in the packaging ecosystem you 
 want to get the closure of this so we 
 you look at the graph and you say okay 
 i'm going to get all the packages i need 
 which depends all on themselves so that 
 i can have the full software package and 
 working on my computer so in nyx we 
 often talk about closure of the software 
 and that means the transitive closure 
 behind the binary relation of 
 dependencies 
 so now maybe i lost some people of the 
 audience and maybe a question i would i 
 would ask is how many people are using 
 links here 
 yeah 
 well that's cool for all the newcomers 
 here 
 so maybe it's a bit obscure so far and 
 it's very normal because that's how nyx 
 is perceived by a lot of people and um 
 one truck one thing it tries to do is to 
 use vertical framework to 
 get the complexity of software tamed 
 so 
 as a goal we nix as hallway as always 
 have 
 had build reproducibility so what i 
 explained about input address or content 
 at rest so once you build the software 
 once you can retry to rebuild it and you 
 will get the same very package 
 something later on that would be funny 
 and build operation are sandbox by 
 default so net no network access no 
 arbitrary access to the user file system 
 or even install dependencies i cannot 
 try to see if you have like i don't know 
 numpy installed if i don't need them buy 
 so uh that's pretty powerful because 
 with help us to 
 see what the software is actually doing 
 in the sandbox 
 and you still have escape hatches 
 if you take some software like steam um 
 well steam is a very bad behaving 
 software because it brings its own 
 libraries because it's trying to solve 
 the problem of libraries so some games 
 are not statically linked they come with 
 libraries and nyx doesn't take the 
 library of overs so we have to make it 
 written live in a file system year arc 
 standard using namespaces and yeah 
 everyone is able to use team on nexus 
 even if it looks like quite hard 
 composition with local package manager 
 is interesting and important nyx is not 
 about reinventing the wheel it's not 
 about like taking over pip or poetry is 
 trying to work with pip and poetry so 
 that it can handle the thing that the 
 distribution the linux depression 
 distribution has to handle while pip and 
 project focuses on what it has to solve 
 and trivial caching 
 as we have reproducibility 
 nix provides a very big 
 binary cache 
 which has everything you contain so even 
 though nixos is a source-based 
 distribution 
 you don't recompile that much 
 i think 
 the only time i compile is because i'm 
 changing something in the c compiler and 
 i'm recompiling the whole world 
 um 
 so i think that's this this chart for 
 ripology.org shows something very 
 interesting that 
 um nyx has a lot of packaged projects 
 and non-unique package projects and of 
 course it's because we are automating a 
 lot of packaging 
 and we are like eating uh packages from 
 pi pi and so on and so forth 
 but we're doing that with a lot less 
 maintainers than something like the arc 
 linux user repository 
 and i think that's very very interesting 
 to to to to see that 
 um 
 because 
 we have a lot of data on what is 
 packaging what is a package and how 
 people use this package and what does 
 this package does 
 we have a minimal image we have 
 came very far on reproducibility on that 
 and 
 we have 
 only two paths which are not 
 reproducible so this is the the website 
 tracking nexus reproducibility so it 
 strength every path that is the 
 derivation in the minimal image and 
 trying to see if it can rebuild it twice 
 on a different kernel different hardware 
 different machine different time and see 
 if there are there are any differences 
 so um four pi so as you can see python 
 and rust something uh are not 
 reproducible um sometimes we are at 100 
 percent and sometimes we are not 
 so it's it's continuously test 
 and as you can see we can 
 look very deep into the problem and see 
 that 
 some 
 pisces file is changing when we're 
 rebuilding twice so maybe 
 non-deterministic optimization or 
 timestamp related issue 
 and that's pretty cool to be able to do 
 that 
 so the question now is how we can 
 leverage nix as a tool 
 so haznix is very strict and the word 
 outside is quite forgiving 
 we have to not re-implement the wheel we 
 have to reuse existing tool 
 like paper and poetry but we have to let 
 nix handle the downloading the native 
 dependency sourcing and capture 
 something in the next expression 
 and we put pip and poetry and every 
 tooling that we use like this in an 
 offline mode that means that we instruct 
 pip to say that we're going to do an 
 offline install and should rely on not 
 using network access 
 so 
 for now i'm going to use a very simple 
 demo 
 of that 
 so here's a next 
 command 
 uh where i'm going to to to create a 
 shell so nick shell is very interesting 
 because it's uh you're all used to 
 virtual off 
 well nick charles is virtual are 
 generalized to everything 
 so you can 
 use any package any binary temporarily 
 in some sort of virtual art and once you 
 exit the shell 
 those packages are not in your 
 environment anymore so what i'm going to 
 do is to have a python 3.9 
 environment with some 
 known to be annoying package to install 
 sometimes on some systems 
 and show that it's quite easy and what 
 happened when you do that 
 of course 
 so 
 you can see that i i made a rookie 
 mistake which is uh assuming that bash 
 was available in my path it is not 
 i have to use off which is the posix 
 standard for that 
 and 
 you can see that nyx is going to to 
 compute the closure of the packages i 
 asked 
 so i have some nice 
 information about the download size the 
 impact size 
 and 
 get everything that i need 
 so it's doing the work and downloading 
 and now i'm creating the environment so 
 i'm in the next show right now 
 so i do have numpy 
 i do have sine pi 
 i do have tensorflow 
 and pytorch 
 once i exit this 
 this shell you can see that i 
 don't have those package 
 in my environment 
 so it's indeed working and i can perform 
 some advanced stuff on this thing 
 because i can change uh the in the 
 inherent 
 numerical library so i can do intel and 
 cal based numpy or scipy 
 and it's quite easy this package this 
 script can be cached so that i can share 
 it with others and they can have the 
 instant shell and not download uh not 
 build a lot of things 
 so it's quite cool 
 and continuous integration becomes a lot 
 easier to test with the with this kind 
 of pictures and the second demo is about 
 a self-contained script 
 sometimes we build some scripts one line 
 script one file script sorry 
 and 
 we don't use 
 external dependencies because it's 
 annoying to package them 
 or to package a one file 
 script with back with dependencies 
 so here's an example we request 
 so i just want to do request get error 
 patent dot io 
 i don't have requests in my environment 
 i don't want to install request i would 
 like to share this file with friends 
 that might use this package 
 might use this script rather 
 and you can see that my 
 cod tool is not finding requests 
 but i can still run it and get an answer 
 because 
 um nikshank has been used as an 
 interpreter 
 for shibang which is a feature of the 
 shells and this way you can do 
 self-contained python script trivially 
 so 
 we've seen how nix can be leveraged as a 
 tool for doing python development 
 we didn't showcase how to do python 
 deployment but the idea is the same you 
 build some closer you send it to the 
 remote server and the remote server just 
 use it uh you can do a lot of advanced 
 stuff meanwhile you can check that the 
 closest is coherent with something you 
 can see in the closer you can generate a 
 software build of materials 
 and 
 a lot of stuff but the problem with nyx 
 is that its learning curve is quite 
 insane 
 so uh not a lot of people are 
 that much graybeard but some tries 
 uh and 
 nyx is like very frustrating for new 
 users uh used to download binaries from 
 the internet and trying to run them 
 we have solutions for that but 
 it's still not easy 
 and nick's cannot solve everything 
 so 
 nyx cannot solve things that were not 
 built for nix 
 meaning that we have a system to 
 determine which packages is hit by cvu 
 but 
 have you ever seen a cvu informing you 
 about the very function who is 
 affected in the security vulnerability 
 so you cannot like say that this is the 
 this particular function which is 
 affected uh this is the hash of this 
 function this is the ash of the code so 
 we cannot automate easily 
 whether we are affecting or not by a cv 
 that's something which is a work in 
 progress uh cvr are very granular 
 sometimes they say to you that in your 
 dependencies you have a package who is 
 vulnerable but in fact you're never 
 using the package so you're not affected 
 and nix can accept that 
 tooling that takes log files and 
 produced next expression are not enough 
 you have a lot of edge cases including 
 in the python 
 registry sometimes some urls are not 
 stable and you have to try to predict 
 things and try to find out about hashes 
 and so on and so forth so it's a bit 
 difficult 
 today there is a 
 bug on poetry 
 which 
 breaks a lot of things 
 and 
 i just got hit by it and i wanted to do 
 a third demo but it doesn't work 
 limits of the standards are also 
 complicated to work around 
 if you take a crate like cryptography 
 which is a python package for doing 
 crypto 
 we have to do this kind of workaround uh 
 to support it because uh it brings a 
 rest compiler in the in the play and 
 unfortunately um the files doesn't bring 
 any ashes about the the ash of the 
 dependencies of the the rest 
 project 
 so we have downstream to support that 
 and try to work around behind the fact 
 that if you are under a certain version 
 we should use the wheel if not we can 
 compile it and here are the dependencies 
 hashed and we can use it extra extra and 
 it's very very complicated so we have 
 been working with cryptography guys on 
 that but 
 the format doesn't support it so it's 
 hard 
 and advanced attackers we just moved to 
 bug doors and now it gets very 
 complicated it's not it's not a 
 technical problem 
 um so we need in the future more 
 financial work to be compatible with 
 python 
 we disable bytecode optimization because 
 the bars are not determinism uh we disa 
 we're not using a lot wheels because uh 
 it's super hard to get right the many 
 linux abi problems 
 but at the same time we have things like 
 trustex which solve distributed trust 
 issue when you have multiple binary cash 
 how do you trust this binary cash what 
 is your policy do you want to do 
 majority votes you ask every cash what 
 is the cryptography hash and you say 
 that if 
 the majority vote in favor of ash and 
 something is not doing it 
 then you reject this cache so it's quite 
 interesting we have the salsa framework 
 which is a framework pushed by some big 
 corp tech 
 companies uh to get high level of 
 assurances in your supply chain in 
 integration with the ecosystem are being 
 published at the moment 
 so the conclusion is 
 installing packages in bytes is 
 dangerous by construction fixing this is 
 complicated uh attacks are running in 
 the wild and we can only measure the 
 public surface raising the cost for 
 attackers is quite easy uh by 
 constraining the attack surface with nyx 
 at least 
 and the real win are in fact that we 
 have a lot of data produced by nx we 
 have the integration with the external 
 ecosystem doing multi-language projects 
 becomes easier with nics and um 
 that's pretty much it uh we left you 
 with some references and do some qa if i 
 have time for it 
 unfortunately out of time so there's no 
 qa but thank you so much for your 
 presentation 
 very good 
 one there's a slight delay to some 
 technical issues just a few minutes 
 never mind we're good to go all right um 
 introducing automated refactoring large 
 python code bases by jimmy thank you 
 hello uh i'm jimmy i'm a staff software 
 engineer at cada so today i will talk 
 about automatic refactoring in large 
 enzyme code bases 
 so 
 we have a large control base and we want 
 to solve two problems 
 called formulating and type checkings 
 those are common python copies problems 
 but it's 
 especially challenging in our logical 
 base 
 so 
 we are carta so it's a financial service 
 provider 
 um so we provide online tools for staff 
 founders to issue stock options to their 
 employees or when investors invest money 
 on stock investors get stocks from the 
 stock so all those different people they 
 can 
 use 
 carda to manage their equality 
 and other than those they can also trade 
 and also get other 
 services 
 on top of 
 this platform including compensation 
 valuation 
 text and final admins 
 so we have a large copies that has 
 developed for 10 years it's python code 
 managed in git 
 it has more than 2 million slides and 30 
 000 files 
 every day 200 active developers 
 continue to 
 commit challenges to it 
 so with such frequent updates every day 
 it will be hard if we want to 
 uh commit a large change let's say we 
 want to modify 20 000 files at the same 
 time 
 uh it's hard to merge this change 
 because it will be basically 
 conflicts with everyone's 
 change 
 and 
 let's talk about code formatting so 
 python 
 provides pretty flexible code style so 
 you can write the same code in very 
 different format 
 so in this example the red block and the 
 green block they are actually the same 
 code in different formats you can use 
 single quotes versus double quotes for 
 string 
 or use different indentation to wrap or 
 unwrap the lines into multiple lines or 
 combine a lot of things in one line 
 in a large copies if every developer 
 they are using different formats 
 then the copies will be less easy to 
 read 
 so we will want to apply a consistent 
 format that way everyone can read and 
 write fast so luckily uh there is a 
 popular tool black for that and we want 
 to apply black in our logical base 
 and it comes with the problem we just 
 talked about we couldn't just run black 
 on our large 
 copies all at once 
 it's hard to merge such big change 
 and what if we take a different approach 
 we split the changes as smaller pieces 
 each one only modify 
 like 20 files then we can incrementally 
 convert our code base 
 into 100 
 black format 
 coverage uh so this approach may work 
 but it comes with other challenge 
 it will introduce actual work you will 
 need to 
 spend some effort on creating and 
 managing those 
 uh small changes you also need to make 
 sure those changes they don't overlap to 
 each other 
 and another challenge is since it's an 
 incremental process 
 we need an effective way to make sure 
 the developers don't introduce 
 regressions 
 during this process if some developer 
 they 
 reformat the code into a different 
 format then it's 
 causing regression 
 and we also want to 
 apply a type checking in our code base 
 so in python it's common to get a lot of 
 type related errors like attribute arrow 
 type arrow 
 or value arrow 
 it's because python is not a strong type 
 language 
 and 
 one effective way to catch those is to 
 get the health from my pi 
 so if we have my pi type checker running 
 it could have make those 
 suggestions like the robots 
 and help our developer catch them 
 but 
 in order to get my pi working we would 
 need to add type notations so for each 
 function definition we would need to add 
 the annotation for each parameter and we 
 return 
 and those 
 are the work that looks simple but 
 in the large copies it's challenging 
 because in our code base there are more 
 than one hundred thousand 
 files 
 hundred thousand functions that means 
 type of patient and if we would need to 
 manually annotate each one it will take 
 forever to finish 
 so that's also challenging 
 and our 
 solution is to use automatic refraction 
 to solve all those problems and 
 challenges 
 so the idea is what if we can automate 
 those incremental changes 
 if we can do that we can solve large 
 scale tech data problems in logical code 
 base 
 and let's take a look at how a code 
 change uh 
 life cycle looks like so this is 
 actually how our developers 
 do their job every day 
 they will 
 take some code paths uh that they want 
 to apply some code change 
 they make the code change create a pull 
 request then it will kick off some 
 continuous immigration tests 
 and the tests may pass 
 then they will want to add stub reviewer 
 to review the change 
 if the test fail it could be the change 
 is wrong so it should be remained 
 or it could be just flaky test then 
 maybe we try after some time we'll make 
 the test pass 
 and after adding reviewers 
 um if we get enough reviews up and 
 approved we can merge the change 
 otherwise we may need to add more 
 reviewers or sometimes need to add need 
 to notify the reviewers in another 
 channel like stack 
 and and sometimes we also need to 
 rebase the request 
 to apply the latest change from the main 
 branch or merge or 
 when there is merge conflict we need to 
 close 
 the pull request and then recreate a new 
 one later 
 and so in this life cycle we want to 
 automate everything so the pin product 
 are those we identified can be automated 
 so we want to build a automatic 
 refactoring framework to automate those 
 then let's talk about the design and the 
 implementation of this framework 
 so there are 
 several considerations we want to design 
 the first one is the size of the code 
 change we want to make sure each code 
 change it's not too big otherwise it's 
 not easy to review it's not too small 
 otherwise we will 
 we will need to create too many 
 important requests which introduce too 
 much overhead 
 so 
 one way to 
 stop this is to 
 just 
 while we walk through the file tree of 
 the large copies we can 
 count the number of python files in a 
 subtree and we only 
 take the subtree as the target 
 or 
 code change 
 path when the number of 
 files is less than our defined threshold 
 so this is one way to implement it 
 another consideration is the number of 
 pending pull requests if we create too 
 much 
 then we will introduce too much too much 
 work to our developers because they 
 still need to do their daily job if we 
 create too many 
 then they will need to spend all their 
 time on reviewing automated proquests 
 they won't have enough time to do their 
 work 
 and if we don't create enough then we 
 won't be making progress 
 so 
 one way to 
 implement these is we can potentially 
 add 
 a consistent label automated with a 
 trend to each created pool quest that 
 way we can use 
 uh the 
 github uh kamen 
 gh to do a query like this to search all 
 the pending pull requests that has this 
 automatic refactoring label 
 so we can 
 run this query to check 
 the pending number of requests 
 and only starting to create more 
 when it's less than the desired 
 threshold 
 and the next consideration is we want to 
 avoid duplications for each code change 
 so 
 that is to avoid conflicts 
 and we can encode the path 
 that we are modifying as part of the 
 pull request 
 one way to implement this is to encode 
 the information 
 as part of the git branch name so for 
 example for black formatting related 
 changes we could potentially use black 
 formatting as the prefix 
 and the target directory name as the 
 prospects 
 and another consideration is incremental 
 adoption so we want to avoid regression 
 while we adopt it so we can introduce an 
 enrollment process 
 so the idea is when a file is black 
 formatted we add the file path to an 
 enrollment list so it's a text file that 
 consists a lot of paths 
 that way 
 we set up a continuous english 
 integration job that always runs like 
 formatting check and all 
 files on this enrollment list 
 so we can make sure no future code 
 changes can 
 break the 
 black format on any of the file 
 so with this approach eventually we will 
 add all the files past 
 into this list then at a time we can 
 remove this list because we reach 100 
 coverage 
 this same approach can also be applied 
 on type annotation adaption process 
 or any other problems 
 so 
 in order to simplify the implementation 
 we can 
 implement each 
 pimp 
 box 
 as independent jobs so let's think of 
 these as a production line so 
 each job is an independent job that 
 moves the 
 pull request from one state to 
 the next state so it's like state 
 machine transition 
 and so if we make each job independent 
 we can just run those jobs periodically 
 so that then they can just move the pull 
 request forward 
 to the end of the life cycle 
 and what other jobs needed we need a job 
 to apply code change and create a pull 
 request another job to quit to check the 
 test status and add reviewer if it 
 passed tests 
 another job to check the review status 
 and add more reviewers 
 or send slack notifications 
 and if it's approved another job will 
 merge the pull request 
 and 
 another 
 job to close 
 the brokers if conflicts happened 
 and we also need to provide an api for 
 our application the refactoring 
 applications for example we can use 
 python abstract best class to define an 
 api 
 refactoring applications 
 and then 
 an application like black promating can 
 just focus on implementing the api to 
 provide needed metadata 
 so the metadata we would need when 
 creating the proquest including the 
 proquest title the labels we want to add 
 the body the commit message so with 
 those we can provide a deep enough 
 detailed information when creating the 
 request then the reviewer can just based 
 on what we provided in the request to 
 review the change 
 we can 
 implement 
 the two different functions 
 the first one is skip a path 
 because we know it's an incremental 
 process 
 so 
 we want to provide a helper for each 
 application to decide whether they want 
 to 
 work on a path or want to skip it 
 and for platform 18 we talk about using 
 an enrollment list so select enroll that 
 text so we can just use a helper to 
 check whether this path is already 
 enrolled if it's enrolled then we want 
 to skip 
 the most important logic is in this 
 refactor api 
 so we want to do two things the first is 
 given the path that we want to apply we 
 want to refactor we will run black 
 command 
 and given the path then black will 
 format the entire path 
 and the second step is to add the path 
 to our enormous list 
 so 
 with an api like this the application 
 just needs to focus on the 
 metadata and the refactoring logic 
 and the remaining work is taken care of 
 by the framework of automatic directory 
 so in order to implement periodical job 
 we can use github workflows 
 you just need to add a gmo file like 
 this 
 in the 
 github workflows directly in your code 
 base 
 with this conflict example 
 you can set up a job to run every 30 
 minutes during the work day 
 and it runs some python code 
 let's take a look at some job examples 
 so first job is to apply code change and 
 create a pull request we can use 
 pi github to create progress easy 
 when you use github workflow you can 
 easily 
 get the provided github tokens 
 and get the current github repository 
 name to set up the 
 github library 
 then the main 
 logic here is to basically walk through 
 each refactoring application by calling 
 the subclass helper 
 for each application we want to check 
 what's the 
 current pending number of prs if only if 
 it's less than 
 the 
 desired 
 threshold 
 then we will fetch the next path and 
 then run the refactor logic 
 and then 
 we will after that we 
 already refactor the code we will commit 
 the change and then create the pull 
 request 
 and when creating a proquest and making 
 a comment we are using all the metadata 
 provided by the application 
 another example job is to merge the 
 approved full request so again we are 
 using 
 hi github to make a query to find all 
 those 
 approved pull requests 
 and for each file for request we can 
 just call the merge helper to merge it 
 in the earlier example we use black 
 comment to refactor the code you may 
 want to build some custom refactoring 
 yourself in that case 
 we can use some other tool let's take a 
 type annotation as example so let's say 
 we want to add some misting types some 
 of the 
 simple functions we can based on simple 
 heuristic 
 and inference to add mission types 
 for example some functions like init 
 function 
 they don't have any return statement we 
 will want to add return now 
 and some functions they only have one 
 single 
 uh return statement at the end and it's 
 returning 
 a simple string 
 like this get bar function we will want 
 to add a str as the return type 
 so 
 um 
 we can use deep cst uh to implement a 
 transformer to 
 do this refactoring for easy 
 so in deep 60 it provides some helper to 
 help us convert the source code as a 
 syntax tree so we can call the 
 parse module in our reflector logic to 
 convert the text as a 
 syntax tree the root node is a module 
 then we can 
 call our 
 transformer admission non-return to 
 convert the syntax tree to 
 add the missing noun type and then 
 eventually we 
 replace the original file as the updated 
 code 
 so 
 the logic are in this admission now 
 return 
 so it's a transformer which allows us to 
 register some callback function to be 
 called during the tree traversal 
 we can 
 define visit function definition 
 function 
 to register a function it will be called 
 whenever we enter a function definition 
 node 
 so with this we can 
 implement 
 this uh 
 so basically we need a converter which 
 is the return code we initialize it as 
 zero whenever we enter a function 
 definition we also reset it as zero and 
 then when we found a return statement we 
 increment the counter 
 and then at the end of the 
 function definition subtree traversal 
 in the lead function 
 we will check whether this current 
 function definition is missing return 
 type 
 and if it's missing return type and the 
 counter is zero that means this function 
 returns nothing so we can safely add the 
 return annotation as now so this is a 
 simple example 
 so we can 
 build more complex 
 reflector 
 and some other more complex 
 dynamic types you may want to get help 
 by collecting runtime types 
 so 
 we can use monkey type tool for this 
 you community type is open an open 
 source tool you can run your program 
 along with monkey type to collect the 
 traces of each function code 
 and then you can run monkey type command 
 to apply the connected types to your 
 code 
 so with this you can just run monkey 
 type in the reflector step to 
 apply the refractory 
 so 
 we already covered the implementation 
 then let's talk about how it works in 
 kata 
 so it for black for meeting we made 
 black two uh two available in our code 
 base uh 
 in 2020 but after a long time 
 not much people start to use it because 
 it required manually brown black until 
 we 
 start automatically factory work we were 
 able to quickly ramp up the coverage to 
 100 
 in a few months 
 so now our entire code base is in black 
 formats 
 um 
 similar pattern happened in type 
 notification so our type imitation 
 coverage 
 it was 
 growing pretty slowly since 2019 
 until we use automatic reflection to add 
 the mixing types 
 we were able to quickly increase the 
 coverage in a few months and we are 
 still continuing the work 
 while we working on increase the time 
 coverage to make pipeline more useful we 
 have seen the number of type errors in 
 our production environment decreased 
 over time 
 the number is 
 fluctuating 
 it depends on the 
 users and the traffic to our service 
 yeah but we do see uh trending is 
 decreasing 
 so here are the summary of the talk so 
 uh automatic reflection is useful if you 
 have a large copies and 
 many tech that to solve 
 because 
 the automatic reflecting framework it 
 enables you to save a lot of manual 
 effort it 
 also allows you to fix technic problems 
 incrementally and continuously 
 and it's not only applicable to python 
 so 
 when we implement our framework we make 
 the api extensible for our programming 
 language so we are actually also using 
 it 
 for 
 typescript in 
 carta 
 so that's it uh uh thank you for your 
 attention so if you are interested in 
 more technical themes in kata we have an 
 engineering blog 
 medium 
 we also have a lot of jobs opening 
 and 
 for all the tools mentioned in the talk 
 you can find the links here 
 [Applause] 
 so now that's it for today uh is there 
 any questions 
 we do have a couple minutes for 
 questions would you like to come up 
 hi um thanks for the talk um a question 
 from experience so in large uh monorepos 
 or in large repositories oftentimes you 
 end up with multiple copies of the same 
 files modules etc and each of those 
 copies can then develop a life on its 
 own so during the refactoring phase like 
 this one uh what's your approach for 
 identifying the duplicates and dealing 
 with duplicates that may have diverged 
 by then 
 um yeah i think duplication is uh 
 it's a common problem in large copies 
 and um 
 based on my experience 
 i i didn't 
 solve this problem yet yeah but 
 i know some 
 uh people may use some tools to detect 
 the 
 uh duplications like sonar cube and then 
 just analyze the code and try to 
 fix the 
 uh depleted code 
 manually but that is not 
 scalable 
 um yeah 
 another 
 approach we did is we try to 
 develop some tools that can help us 
 i mark some piece of code as a 
 deprecative code and forbid the other 
 people to use it 
 using linters so we 
 don't develop a tool called 
 decomposition toolkit 
 to help 
 our developers 
 use it to mark the code and then they 
 can track the progress or they can count 
 the number of references 
 in a 
 dashboard and then eventually the linter 
 will prevent new 
 reference 
 yeah 
 that is 
 my experience 
 hi jimmy great talk thanks um so seems 
 like this framework would be pretty 
 useful for anyone running on github any 
 plans to open source it or 
 are you aware of anything already open 
 source that's in similar 
 state 
 um 
 yeah that's a good question as far as i 
 know i didn't know any 
 service like this is open sourced and 
 uh in our 
 uh inter 
 implementation in carla we we started 
 the implementation with circle oci not 
 github workflows 
 um yes but so i i think it's probably 
 more easier to use if it's implemented 
 in in github workflows 
 um so that is something i will consider 
 to discuss with my team to 
 make it open source yeah because we 
 other than 
 the implementation of the workflow we 
 did implemented a lot of 
 python helpers to make building a 
 framework easier so that that library 
 could potentially be 
 open sourced 
 well that's all our time so thank you so 
 much jimmy for your presentation 
 thank you 
 um 
 you are actually very serious when you 
 are recording me 
 what did i learn today well i learned 
 that there is a great python community 
 in prague 
 and it would be great to organize maybe 
 the next europe python there that would 
 be fantastic a great city great people 
 great beer 
 that that would be fantastic 
 today today i learned 
 well how to do an interview i guess 
 the community the people 
 and talking 
 and 
 learning new things 
 i don't know it's fun 
 we had a really interesting discussion 
 about euro python society and you know 
 how 
 um things were before how things are 
 right now there were some really 
 interesting conversations about what 
 could be done to be like more community 
 centered for us to be more community 
 centered how we can help more open 
 source um organizations and more 
 specifically just be more closer to the 
 community 
 so today at euro python i learned about 
 how 
 the new python versions will be 
 optimized and how they will run faster i 
 think that's great news for the future 
 of python 
 the european is the gathering of 
 different groups different faults 
 different ideas and but everybody is 
 sticking together with a common language 
 which is python something i really liked 
 learning about which was really cool was 
 these 
 vs code pets which you can have some 
 pets running around in vs code and what 
 i really like about your python is uh 
 now that we're not remote anymore is 
 actually talking to people meeting 
 people and interacting and especially 
 comparing uh 
 developer setups which we were just 
 doing just now that's really cool 
 during 
 our preparations for europe iphone i've 
 learned some animal parts like 
 that giraffes have actually vocal 
 vocals and they can speak 
 everything everyone does with python and 
 that's probably one of my favorite 
 things and is the surprises you get from 
 even when you read the abstracts of the 
 talks and you get you think you know 
 what they're going to be talking about 
 and then you go to a talk that you think 
 you will not enjoy that much and it just 
 completely blows your mind 
 and that's that's really really cool 
 this year in europe a lot about the 
 streaming and 
 video cameras and all those things 
 knowing people and knowing 
 many different society europa society 
 and python 
 community members but i think it's 
 very important if you want to be 
 occupied 
 if you want to participate 
 i think my favorite thing about euro 
 python is well the people the people 
 real quite just fantastic it's the best 
 people i've ever met 
 for me it's like a 
 nerd camp for 
 all the nerds so it's really nice to 
 meet all the people that i see only once 
 per year at the conference 
 talks are really nice i 
 i learn for example about linters for 
 the import statements which i still have 
 to read about but 
 i learned quite a lot from that 
 this year meeting a lot of friends in 
 person so i've been in europe for three 
 years and this is my first time meeting 
 all of you in real life and that was 
 just amazing 
 i got five minutes five minutes to 
 prepare for a session share and then 
 after all i got loads of people coming 
 saying thank you and they say that they 
 loved it so i think that was a great job 
 and i had fun doing it 
 i think every every day there is 
 something new and funny 
 i think it's just fantastic highly 
 recommend europe python and hopefully 
 see you next year 
 umnitza is the enterprise technology 
 management solution that consolidates 
 data from existing siloed tools to 
 provide a single source of truth for 
 endpoints applications cloud networking 
 and accessories 
 with imnitza you can automate processes 
 from purchase to end of life achieving 
 five key benefits 
 find out how umitza can give you 
 complete control and insight across your 
 technology portfolios book a live demo 
 today at umnitza.com 
 [Music] 
 [Music] 
 [Music] 
 [Music] 
 you are actually very serious when you 
 are recording me 
 did i learn today 
 well i learned that there is a great 
 python community in prague 
 and it would be great to organize maybe 
 the next euro python there that would be 
 fantastic a great city great people 
 great beer 
 that that would be fantastic 
 today today i learned 
 well how to do an interview i guess 
 the community the people 
 and talking 
 and 
 learning new things 
 i don't know it's fun 
 we had a really interesting discussion 
 about euro python society and you know 
 how 
 things were before how things are right 
 now there were some really interesting 
 conversations about what could be done 
 to be like more community centered for 
 us to be more community centered how we 
 can help more open source um 
 organizations and more specifically just 
 be more closer to the community so today 
 at europa python i learned about how 
 the new python versions will be 
 optimized and how they will run faster i 
 think that's great news for the future 
 of python 
 the european is the gathering of 
 different groups different faults 
 different ideas and but everybody is 
 sticking together with a common language 
 which is python something i really liked 
 learning about which was really cool was 
 these 
 vs code pets which you can have some 
 pets running around in vs code and what 
 i really like about europe python is uh 
 now that we're not remote anymore is 
 actually talking to people meeting 
 people and interacting and especially 
 comparing uh 
 developer setups which we were just 
 doing just now that's really cool 
 during 
 our preparations for your python i've 
 learned some animal parts like 
 that giraffes have actually vocal 
 vocals and they can speak 
 everything everyone does with python and 
 that's probably one of my favorite 
 things and is the surprises you get from 
 even when you read the abstracts of the 
 talks and you get you think you know 
 what they're going to be talking about 
 and then you go to a talk that you think 
 you will not enjoy that much and it just 
 completely blows your mind 
 and that's that's really really cool 
 this year in europe i learned a lot 
 about the streaming and 
 video cameras and all the things knowing 
 people and 
 knowing 
 many different societal side members and 
 community members but i think it's 
 very important if you want to be 
 occupied 
 if you want to participate 
 i think my favorite thing about euro 
 python is well the people the people 
 real quiet are just fantastic it's the 
 best people i've ever met 
 for me it's like a 
 nerd camp for 
 all the nerds so it's really nice to 
 meet all the people that i see only once 
 per year at the conference 
 talks are really nice i 
 i learned for example about linters for 
 the import statements which i still have 
 to read about but 
 i learned quite a lot from that talk 
 this year meeting a lot of friends in 
 person so i've been in europe for three 
 years and this is my first time meeting 
 all of you in real life and that was 
 just amazing 
 i got five minutes five minutes prepare 
 for a session share and then after all i 
 got loads of people coming saying thank 
 you and they say that they loved it so i 
 think that was a great job 
 and i had fun doing it 
 i think every every day there is 
 something new and funny 
 i think it's just fantastic i highly 
 recommend europe python and hopefully 
 see you next year 
 umnitza is the enterprise technology 
 management solution that consolidates 
 data from existing siloed tools to 
 provide a single source of truth for 
 endpoints applications cloud networking 
 and accessories 
 with imnitza you can automate processes 
 from purchase to end of life achieving 
 five key benefits 
 find out how umnitza can give you 
 complete control and insight across your 
 technology portfolios book a live demo 
 today at umnitza.com 
 [Music] 
 [Music] 
 [Music] 
 [Music] 
 so 
 take one 
 you are actually very serious when you 
 are recording me 
 what did i learn today 
 well i learned that there is a great 
 python community in prague 
 and it would be great to organize maybe 
 the next euro python there that would be 
 fantastic a great city great people 
 great beer that that would be fantastic 
 today today i learned 
 well how to do an interview i guess 
 the community the people 
 and talking 
 and 
 learning new things 
 i don't know it's fun 
 we had a really interesting discussion 
 about euro python society and you know 
 how 
 um things were before how things are 
 right now there were some really 
 interesting conversations about what 
 could be done to be like more community 
 centered for us to be more community 
 centered how we can help more open 
 source um organizations and more 
 specifically just be more closer to the 
 community 
 so today at your python i learned about 
 how 
 the new python versions will be 
 optimized and how they will run faster i 
 think that's great news for the future 
 of python 
 europe python is the gathering of 
 different groups different faults 
 different ideas and but everybody is 
 sticking together with a common language 
 which is python something i really liked 
 learning about which was really cool was 
 these 
 vs code pets which you can have some 
 pets running around in vs code and what 
 i really like about your python is uh 
 now that we're not remote anymore it's 
 actually talking to people meeting 
 people and interacting and especially 
 comparing uh 
 developer setups which we were just 
 doing just now that's really cool 
 during uh our preparations for europe 
 iphone i've learned some animal parts 
 like uh 
 that giraffes have actually vocal 
 vocals and they can speak 
 everything everyone does with python and 
 that's probably one of my favorite 
 things and is the surprises you get from 
 even when you read the abstracts of the 
 talks and you get you think you know 
 what they're going to be talking about 
 and then you go to a talk that you think 
 you will not enjoy that much and it just 
 completely blows your mind 
 and that's that's really really cool 
 this year in europe i learned a lot 
 about the streaming and 
 video cameras and all those things 
 knowing people and 
 knowing 
 many different society europa league 
 members and python 
 community members but i think it's 
 very important if you want to be 
 occupied if you want to participate and 
 join this community i think my favorite 
 thing about euro python is well the 
 people the people real quiet is just 
 fantastic it's the best people i've ever 
 met 
 for me it's like a 
 nerd camp for all the nerds so it's 
 really nice to meet all the people that 
 i see only once per year at the 
 conference 
 talks are really nice i 
 i learned for example about linters for 
 the import statements which i still have 
 to read about but 
 i learned quite a lot from that 
 this year meeting a lot of friends in 
 person so i've been in europe for three 
 years and this is my first time meeting 
 all of you 
 in real life and that was just amazing 
 was i got five minutes five minutes to 
 prepare for a session share and then 
 after all i got loads of people coming 
 saying thank you and say that they loved 
 it so i think that was a great job 
 and i had fun doing it 
 i think every every day there is 
 something new and funny 
 i think it's just fantastic i highly 
 recommend europe python and hopefully 
 see you next year 
 umnitza is the enterprise technology 
 management solution that consolidates 
 data from existing siloed tools to 
 provide a single source of truth for 
 endpoints applications cloud networking 
 and accessories 
 with imnitza you can automate processes 
 from purchase to end of life achieving 
 five key benefits 
 find out how umitza can give you 
 complete control and insight across your 
 technology portfolios book a live demo 
 today at umnitza.com 
 [Music] 
 [Music] 
 [Music] 
 [Music] 
 okay 
 so um 
 i'd like to present uh dr 
 arjuman and dr atif for this next 
 presentation python for arts humanities 
 and social sciences 
 thank you very much 
 hello everyone my name is atef so i'll 
 be presenting the first half of the talk 
 and then 
 urgement will be speaking the later off 
 so the topic is around python for arts 
 humanities and social sciences 
 both of our backgrounds in terms of 
 the training is coming from computer 
 science but both of us are applying now 
 python 
 and also cs as whole in arts humanities 
 and social sciences 
 the talk is organized 
 by 
 following content so we are going to 
 touch base on what is ahss a bit on our 
 experience and exposure coming from data 
 science artificial intelligence because 
 it's very 
 dominant and there are some data science 
 roles where there is a difference 
 between stem and ahss so i'll just throw 
 a bit of light on that 
 some bits on python and technology 
 followed by case studies which would be 
 covered by arjun 
 um so 
 arts humanities and social sciences um 
 you know 
 the academic counterpart to this is stem 
 where we know like science technology 
 engineering and mathematics 
 but when it comes to arts humanities and 
 social sciences this is where the user 
 or the human exists a lot of the time 
 when we are trying to solve a problem 
 it's most mostly about humans so if 
 you're even trying to solve a problem 
 from computer science you're trying to 
 solve a problem that exists outside of 
 computer science mostly 
 which is why 
 we see a lot of interdisciplinary 
 roles within computer science as well 
 and applications and so on and so forth 
 one of the challenges that we have with 
 when it comes to arts uh humanities and 
 social sciences is uh lower attention 
 has been given to this because there has 
 been drive towards stem more often 
 however the problems are 
 now coming from ahs more more often than 
 it was coming before 
 within universities arts humanities and 
 social sciences they get less attention 
 compared to stem 
 but uh recently this this there is a 
 change there is a drift uh towards there 
 is a push towards arts humanities and 
 social sciences 
 in europe and uh and also abroad 
 however 
 uh searching for a common good in the 
 domain of uh humanities it's a big thing 
 uh for the causes such as social social 
 good uh social welfare and you know for 
 the society for uplifting it for for 
 futuristic smart cities and all those 
 kind of things but the whole point here 
 is human in the loop or we are trying to 
 solve a problem for the human that is 
 where the humanities is quite important 
 in uk uh it has been rebranded because 
 the attention has not been given like as 
 soon as people hear 
 arts humanities and social sciences for 
 some reason there is a stigma around it 
 uh in the in the minds of the students 
 and as well as in the society so they 
 tried to change it and bring it shape 
 they call a shape which which means 
 simply social sciences humanities arts 
 uh for people and the economy and of 
 course when there are people there are 
 society there is economy 
 now when we see a big picture when we 
 talk about data science or maybe perhaps 
 artificial intelligence we see a lot of 
 intersections here where a lot of things 
 happen for instance if i show you there 
 is computer science and when we try to 
 merge it with business or business 
 problems we have traditional software's 
 such as excel such as powerpoint because 
 they're kind of tools that try to solve 
 some of the business problems 
 but when we try to mix computer science 
 with maths and statistics this is where 
 we usually see machine learning 
 uh and when we try to mix maths stats 
 with business or any domain uh which 
 could be arts humanities and social 
 sciences as well we kind of get data 
 analysis where most of the traditional 
 research takes place but when we combine 
 all these three together we kind of get 
 what we call data science which is where 
 you have you know computer science as a 
 tool and then maths and stats kind of 
 provide you with the theory and then uh 
 business or the domain provides you the 
 context that you're trying to solve 
 and in in this intersection there is a 
 great support coming from python for 
 instance 
 uh when we talk about statistics in 
 analytics these are the two of the 
 common terms that are being used uh when 
 we talk about statistics uh and you talk 
 to a computer science person uh they 
 might be talking about mostly about 
 descriptive statistics or perhaps eda 
 exploratory data analysis if you may 
 call it that way 
 where the idea is to look for or 
 describe what has happened in the past 
 rather than predicting what's going to 
 happen in the future this is what 
 traditionally is declared as descriptive 
 statistic which is kind of also my 
 background in the sense because i'm 
 coming from computer science the other 
 side when you talk to a person who's 
 coming from a computer science 
 background they might be interested in 
 something which they call predictive 
 analytics which is where they're trying 
 to use the data and trying to predict 
 something in the future 
 where are there other other two areas 
 where mostly arts humanities and social 
 sciences people are interested which 
 comes from statistics is around 
 inferential statistic where they're 
 trying to build a hypothesis and they're 
 trying to test it 
 which is a little different from what we 
 do in predictive analytics where we are 
 trying to predict the future 
 likewise there is another discipline 
 where business and hearts and humanities 
 and social sciences people are 
 interested is called prescriptive 
 analytics where is the domain of like 
 what should be done uh simulation 
 rule-based approaches to trying to solve 
 a problem or perhaps recommending a 
 different path 
 the interesting bit over here is when we 
 discuss about python or the application 
 of computer science or the application 
 of data science uh you can see all four 
 of them playing a huge role 
 and if a person is coming from computer 
 science mostly there are in these two 
 areas which are like uh pointed out with 
 the arrows whereas if somebody's coming 
 from statistical background they would 
 be uh more inclined towards these two 
 then there are a lot of applications of 
 ai now when we talk about like as i've 
 mentioned earlier 
 um 
 computer science is not solving its own 
 problem as much as it's trying to solve 
 other problems so you can see we're 
 trying to make you know traffic 
 experience better through automobile 
 applications trying to solve problems of 
 the business education finance 
 manufacturing gaming government 
 healthcare you just name it like the 
 applications are limitless but most of 
 them come from the domain expertise 
 which are outside of computer science 
 now when it comes to data science there 
 are two distinct kind of roles uh 
 first role that i mean first of the type 
 of the role that i say more suited 
 towards stem people but there are other 
 kinds of role that are 
 suited more towards ahsss so when we 
 talk about somebody who is a data 
 scientist and of course when we talk 
 about data science we talk about python 
 automatically okay because python is is 
 the dominant language here as well so uh 
 when it comes to data science it means 
 like the person will do almost 
 everything from visualization from 
 collection of data analysis presentation 
 and everything if the person can do that 
 we call that person a data scientist 
 however we know that 
 having an all-rounder best all-rounder 
 it's it's it's it's like very difficult 
 to achieve so you might come across 
 people having uh stronger abilities in 
 one of the identified areas for example 
 they might be very clever 
 when it comes to analysis but they could 
 do a bit of uh visualization and so and 
 so forth so 
 it's it's like it's in demand lots of 
 companies wants to have a data science 
 scientist then there are machine 
 learning experts who are mostly about 
 creating new methods uh 
 trying to create new models doing a 
 research breakthrough kind of a thing 
 they're always trying to change 
 something around uh an improvement of 
 the accuracy and and so and so forth 
 they might be coming from an academic 
 background and they might be just trying 
 to publish their new research uh so they 
 they are in that area so these two are 
 mostly stem 
 roles 
 then we have data engineer and data 
 architect 
 these two are about how can we build the 
 pipelines on the data 
 so how can we manage the data and the 
 sql and the storage and all these kind 
 of things or the big data 
 there is a subtle difference between 
 data engineer and data architect data 
 engineers are the ones that are 
 responsible for designing and developing 
 and maintaining the entire data pipeline 
 test the ecosystem which is required for 
 the businesses and prepare the data for 
 everybody else who who is in the team 
 but mostly for data scientists 
 whereas data architects try to give a 
 well-formatted data 
 produce a schema thinks about how to 
 bring in structure so that everybody can 
 access the information in through a 
 structured way 
 but again these two roles are stem as 
 well 
 then there are database administrators 
 which are commonly known to businesses 
 as well uh these are the people who can 
 you know pull out information from the 
 databases um and they are of course of 
 stem as well 
 then there are technological special 
 technological specialized roles such as 
 you know nlp explorer deep learning 
 experts and so and so forth whatever is 
 required by the industry 
 again mostly they are coming from stem 
 areas 
 now there are other rules when we talk 
 about such as data analysts uh such as 
 machine learning engineer they are more 
 suited towards ahss however they might 
 be coming from stem too there is a 
 blurry 
 blur boundary here but if you see from 
 the point of view of analyzing something 
 in the context of business and if they 
 don't understand business if they don't 
 understand the importance of the human 
 who's behind that uh then performing 
 such an analysis or performing a 
 visualization and trying to uh uh you 
 know trying to analyze what is important 
 becomes very difficult so you have to 
 become more expert of the domain and 
 then you should know the right tools uh 
 just a bit instead of you know in 
 instead of like uh showcasing that you 
 know a lot of tools you just need to 
 know a few tools but really tell the 
 story 
 in terms of machine learning engineer 
 who's different role compared to machine 
 learning scientists scientists are 
 trying to chase for you know one person 
 accuracy boost come up with a new 
 modeling strategy whereas engineers are 
 the ones who are trying to plug in what 
 is already available in machine learning 
 and then try to solve a problem that's 
 where they understand the problem more 
 than they can develop more of the 
 machine learning and advanced machine 
 learning in terms of the theoretical 
 space 
 then there are um 
 people from data storytellers 
 those who can tell the story from the 
 data and they can you know inspire 
 people 
 or you know businesses and as well as 
 society wherever the application is and 
 that's where they need to connect with 
 with the real society or the real people 
 who are going to benefit from it and 
 that's why it belongs to ahss 
 likewise there are people from business 
 intelligence development and they are 
 called bi developers they understand the 
 business and they just try to tell the 
 story or try to solve the problem for 
 the business they might not know much of 
 data science in the details but they do 
 understand just enough to uh 
 make use of the tools which are 
 available uh to answer the queries for 
 for businesses 
 now when it comes to 
 you know uh python we have a create 
 support for machine learning algorithms 
 just to show you like this is how it 
 looks like right this is just a small 
 subset of how the real 
 uh you know support that exists within 
 python as well these are all nearly 
 algorithms which are all supported in 
 python 
 now you can see with scikit-learn there 
 is a path 
 from where you can start you can think 
 about how you can you know if if you 
 have such a data set and you want to 
 grow from there what is the pathway that 
 you should take and try to solve the 
 problem so there is a strategy there is 
 a cheat sheet which is available and of 
 course it's growing as well it's just to 
 you know just to highlight what exists 
 over there already 
 then we have different types of neural 
 networks you can assume that as a you 
 know 
 a rat's brain is different from an 
 elephant's brain from a monkey's brain 
 from a human's brain whatever is suited 
 you just need to borrow that and try to 
 solve the problem if the problem looks 
 like a rat's brain is enough so you need 
 a small neural network to solve that 
 problem whereas if the problem is 
 different you have to go for a different 
 architecture so there is a variety of 
 choices that exist out there 
 now the problem what has happened over 
 the last couple of years is we have lots 
 of technology and some of the quotes 
 that i would like to point out over here 
 we have lots of technology available now 
 it's mostly about the right selection of 
 the technology 
 for the businesses to benefit from it so 
 we don't need to say yeah there is 
 another technology out there so what so 
 the problem here is what is the right 
 side of technology another thing is 
 computer science has become more like a 
 calculator for the other disciplines but 
 the problem here is 
 uh this calculator is quite different 
 from the calculator that we knew you 
 know a few years ago or decades and you 
 know centuries ago and not centuries ago 
 but decades ago 
 so 
 this requires a person who understands 
 it and then you know prescribe 
 what you need from it 
 another thing is computer science is 
 kind of an analogous to uh 
 you know the spice of a cuisine and that 
 cuisine actually belongs to different 
 disciplines which could be outside of 
 computer science 
 and if you put too much of a spice it 
 will spoil the dish it's like too much 
 of a technology will not be good and if 
 you don't give it enough technology it 
 will sound tasteless and this is where 
 python is quite good because it has a 
 lot of support and just requires people 
 to tailor it and then prescribe it as a 
 solution for other disciplines as well 
 so python is not just for computer 
 science but of course beyond for that 
 and here i'll stop and hand it over to 
 argument for the rest of the part 
 so my colleague covered what data 
 science is why social science and 
 the boundaries are blurring now but when 
 it comes to actually teaching 
 programming and python to the 
 arts humanities and social science 
 students there are 
 quite a few challenges and the top most 
 of which is that there is this fear 
 within them like dominion shows 
 so 
 the real 
 issue that we face coming from a 
 computer science background to an ahss 
 school or ahss students 
 is how to make students overcome that 
 fear so 
 over 
 my 
 one year exploration of this area or 
 maybe two years 
 what i have learned is that 
 don't make them think so much about the 
 programming task at hand 
 give them what they want in terms of 
 their social science problem curiosity 
 driven exploration because they are 
 solving social science uh humanities 
 disciplines are about solving problems 
 of humanity problem of society 
 so 
 tell them okay this problem that you 
 want to solve of society you do surveys 
 you do interviews computer science has 
 the right amount of tools not just the 
 right amount but also 
 a mix of different tools that can help 
 you get the data do some analysis eda 
 over it to make your job easy and that's 
 when they stop thinking about the fear 
 us aspect of it and 
 get curious towards how that technology 
 can give them more insights 
 for example 
 this is a postdoc position 
 advertised by an interdisciplinary team 
 in germany 
 now you can see that the topic is 
 politics of inequality which is coming 
 from a social science problem 
 but they want somebody 
 who also has a background in python 
 in some of the technologies so this is 
 the kind of work that's happening in 
 research departments this is the kind of 
 research problems that computer 
 scientists or social scientists with a 
 little bit of technology can solve 
 so if you motivate them that 
 okay let's take a problem of society 
 which i'll also explain as i go on which 
 i did with the business school 
 and also in another project on 
 immigration 
 and but first another thing to you know 
 make their fear go away is to break that 
 problem down into smaller problems and 
 for each set of problem give them a 
 notebook or a small demo 
 that fascinates them 
 and 
 makes them like less worried about the 
 programming and the syntax stuff and 
 that has worked a lot 
 now this was 
 it's available on my github 
 so 
 during the last year i taught in a 
 fintech module at tu dublin 
 technology university dublin and 
 being from a computer science background 
 it was slightly 
 my first experience and i was like how 
 am i going to teach business school 
 students and their background was of a 
 right one there was a rugby player in my 
 class 
 there were two students from 
 direct provision 
 so those of you who don't know direct 
 provision is ireland's asylum system 
 where refugees are housed 
 so 
 there was like huge and one were two or 
 three were quite good in programming 
 already so to take them all along in one 
 class was quite a bit of a challenge 
 some were at times nervous 
 that 
 the students who already know 
 programming they're not letting us learn 
 they're going too fast they're answering 
 all your questions you know stuff like 
 that so and then i had to come up with 
 something that would be challenging for 
 everybody 
 not just those students who were 
 already familiar but 
 also those who wanted to study the 
 business side of things the finance side 
 of things so anybody who's in finance 
 and business knows that tesla is the hot 
 thing 
 so i 
 created this project about tesla news 
 articles 
 i script some news articles and they had 
 to do sentiment analysis over it and 
 then use those sentiment analysis 
 features as predictors for the company's 
 financial performance 
 another thing that helped was 
 providing them with starter code so 
 i gave them skeleton code at first they 
 were struggling like how do we even 
 start how do we read those files how do 
 we read the csvs and get the sentiments 
 and so that part if you go to my github 
 and you want to teach finance students 
 this project everything the whole 
 instructions is up on my github i'll 
 also share on twitter later 
 so this worked really well 
 and the students were like towards the 
 end they were very very happy that we 
 solved a very nice programming project 
 and when there when i saw the reports it 
 seemed as if there was also a part where 
 they had to do you know different 
 feature engineering and a lot of them 
 put 
 well not everybody but some of the 
 groups put in a lot of effort into that 
 and that helped bring out their creative 
 side 
 so it was a very good experiment 
 this project is part 
 funded by 
 ice research council 
 and they are 
 the other main funders and it's called 
 in inclusivire r is short for ireland 
 and 
 it involves a 
 school of 
 business in tu dublin and school of 
 computer science in 
 ucd 
 so the whole idea is that what we are 
 doing we are doing surveys and focus 
 groups and gathering quantitative data 
 from that part and applying those 
 insights to 
 social media gathering uh data from 
 social media to develop a tool for 
 detecting uh 
 sentiment around migrants in ireland 
 uh with time especially during covet it 
 was noted that ireland is getting less 
 friendly towards migrants this wasn't 
 the case 
 few years ago but it has increa or maybe 
 it was we never knew 
 but 
 some 
 aspects 
 that social scientists always knew but 
 we as computer science stone 
 came out with this study especially like 
 some interesting insights in relation to 
 the various nationalities that live in 
 ireland i'll present a graph 
 so this box plot is showing something 
 very very interesting 
 and 
 this came from a theory of by a post 
 talk of international business now my 
 background is not business i don't know 
 about this stuff 
 that there is something called cultural 
 distance 
 and 
 ireland's cultural distance 
 with respect to 
 anglo-saxons now anglo-saxons would be 
 people from the u.s 
 uk 
 uh confucians 
 people from china 
 hong kong 
 vietnam those asians eastern europeans 
 eastern europeans would be poland 
 ukraine 
 uh koloakia countries like that and 
 latin america brazil chile that part of 
 the world's middle eastern region so 
 this cultural distance value we clust 
 made these clusters of countries based 
 on cultural distance value uh derived 
 from international business 
 now we see an interesting pattern here 
 if we would have done all the migrants 
 together maybe this wouldn't have not 
 been so obvious 
 some communities 
 find it 
 very hard to make friends that are 
 native irish native here 
 we refer to those who have been in 
 ireland who are born irish 
 so 
 overall 
 uh what this is representing four would 
 be 
 that the question was the survey 
 question was do you find it easy to make 
 irish friends 
 and strongly agree was five means you 
 might you've defined it very easy and 
 strongly disagree was one so you see 
 sorry strongly disagree uh was a higher 
 number 
 so the latin american and africans they 
 find their mean is the same four so they 
 find it harder but within the latin 
 american ones you see that even the 
 lower quartile has a lower number so 
 they are struggling more so there's wide 
 variation in the africans some africans 
 would find it easy but overall the latin 
 americans and that makes sense if you 
 read the news articles in ireland you 
 would see that a lot of the delivery 
 drivers who are facing a lot of racism 
 they are from latin america 
 it if it would add up with the data from 
 social media from the web so that's a 
 very interesting outcome of this project 
 uh and this one 
 is an ongoing part 
 uh what we did here was that we gathered 
 tweets of migrants and natives 
 they were manually 
 tagged for what who is an uh who is a 
 native and who is a migrant the data set 
 of this 
 uh will be made publicly available 
 hopefully because it's twitter data and 
 uh twitter terms of service allows it 
 uh but it's still a work in progress and 
 when the 
 findings will be published then 
 hopefully it will be released along with 
 the data 
 so 
 an interesting aspect is so what i would 
 what this graph is showing is that i 
 just 
 used word embeddings 
 on the tweets of migrants and natives 
 and then i applied k-means clustering 
 to those words and 
 based on tsne 
 reduction was applied you know to 
 visualize now two of these clusters 
 label but the one with the label zero uh 
 the purplish one and the one with the 
 label two the greenish one you would see 
 that in the green one 
 there are a lot of migrants 
 and that one label two is about nmh 
 abortion now there's this whole 
 controversy around 
 ireland's national maternity hospital uh 
 it's being given to a church called 
 saint vincent's 
 and 
 a lot of 
 natives seem concerned about it but the 
 migrants not so much they didn't tweet a 
 lot about it so this also is showing the 
 topics that migrants talk about over 
 their social media and natives talk 
 about over the social media can tell the 
 level to which there is an integration 
 into the society that's what we're 
 trying to do via this project so the 
 whole idea 
 of this is the code hopefully i will be 
 able to share it soon 
 because the project will be the data 
 will be made available but my whole 
 point is that if you take up problems 
 from humanities and social science and 
 try to come up with uh data science 
 methods 
 and python has very very effective tools 
 like gen sim word embeddings nltk if you 
 try to solve it with that you'll get 
 very very interesting insights and ideas 
 and that's what's 
 motivating the arts humanities and 
 social science disciplines towards it in 
 fact there's a whole new field called 
 computational social science 
 so thank you 
 [Applause] 
 thank you so much 
 [Applause] 
 you
